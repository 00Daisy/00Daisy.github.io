[{"categories":null,"content":"RUBY 一、symbols 字串符號 唯一且不會變動的識別名稱 效能比較好，不需要額外的空間來儲存\n字串物件(string)每次都會更新記憶體位置，效能不如symbols但優點是有許多方法可以使用如: reverse, size, downcase\n二、 問號跟驚嘆號\n在 ruby 定義方法時，問號跟驚嘆號也是方法的一部分。\n一般使用問號時，慣例上是表示這個方法會回傳布林值 (true 或 false)\n使用驚嘆號，通常是表示這個方法可能會有「副作用」或「驚喜」，例如陣列有個叫做 uniq 的方法，它可以產生一個元素不重覆的新陣列。\nuniq 方法會回傳一個新的陣列回來，不影響原來的資料\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq p original_list [1, 3, 4, 2, 5, 2, 3] p uniq_list [1, 3, 4, 2, 5]   但如果你是使用有驚嘆號版本的 uniq! 就不同了，原本的陣列也被改變了。\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq! p original_list [1, 3, 4, 2, 5] p uniq_list [1, 3, 4, 2, 5]   三、join、split join 用於將陣列( array )中的元素( element )轉成字串( string )。\nsplit 用於將字串( string )轉成陣列( array )\n四、module 與 modle\n五、namespace\nRails 一、型態 text(文字) 與 string(字串)\ntext 是一種二進位，binary 的格式。可以放的字非常多，可能幾千、幾萬個字，可以使用在如文章內文\nstring 能放的字比較少，使用在文字不會太長的情況，例如文章標題\n二、什麼是 migration\n一種描述資料表該長什麼樣子的描述檔，可以漸進式的去修改你的資料表\n優點: 有紀錄，是一連串的檔案，為資料表的演進過程(欄位變化，新增修改刪除) 可以進行版本控制\n如果要使 migration 具現化，在終端機下指令：\nrails db:migrate 三、CSRF 攻擊\nCSRF (Cross-site request forgery)，跨站請求偽造。目的不一定是要取得使用者帳戶的控制權或個資，但可以用其他使用者的名義執行某些操作。\n這類攻擊的特點是以使用者身份發起\n例如，駭客想刪掉某個 Blog 平台的文章，雖然他沒有這個網站的使用權限，但猜到了後台的路徑: /admin/posts/1便可以使用 delete 方法來刪除。接著把這個連結包裝成中獎資訊，寄送給有權限且剛好處於登入狀態的 X 先生，當 X 先生點下連結，文章就會透過 X 先生的權限來刪除了。\n這個例子中，CSRF 攻擊之所以可以成功，並不是因為駭客獲取 X 先生 的 cookie 資訊，而是偽裝成是 X 先生。\n解決方法:\n 檢查 referer 欄位 (可透過檢查 Header 中的 Referer 欄位是否存在及是否為正常流程網域，藉此確認發送端的前一個頁面是否被偽造或合法使用。) 加入驗證 token (除了驗證 Cookie 的 Token 之外，還需另外在 Request 中放入隱藏的動態 Token 參數。等同於要求每次的 Request 都必須帶上密碼)  四、什麼是 erb 檔 可以在 HTML 裡面寫 ruby 的程式碼。ERb其實可以用來產生任何文字檔格式，例如CSV、XML、JavaScript等等\n五、N+1\nN+1 指的是 SQL 撈資料時，明明可以一次撈完 (例如要三筆資料)，卻使用逐筆撈資料的方式處理 (每次只撈一筆資料) 1次查詢 + N 次的關聯資料查詢就會讓資料庫效能損失\n解決方法: 查詢資料的過程中，使用includes多撈一點資料回來。變成 1 + 1\n六、中控台模式 rails console\nrails c 可在裡面修改資料及查詢資料。 跟 irb 本質上沒有太大差別，中控台模式會把整個 rails 環境，包含相關model 、相關套件整個載下來。\n而 irb 就是一般 ruby 環境\n七、ORM\nObject Relational Mapping\n目的: 簡化資料庫操作語法\n透過物件的方式，去操作資料表，再換句話說， 把物件導向的語法，透過model，轉換成 SQL 查詢語句，對開發人員來說輕鬆很多。撈回來的資料再交給 model 物件化\n例如: Book.all 等同於 select * from books\n SQL 可以被 ORM 取代嗎？\n 當遇到問題時，比如效能，還是需要在 log (紀錄) 裡看 SQL 的語法，看是否寫錯造成翻譯錯誤。 複雜的查詢還是必須使用 SQL 語法   ORM 基本操作 CRUD\nC new 新增一筆資料 create 新增一筆資料，並寫進資料庫 (寫入失敗時默默 rollback) create! 同上，但寫入失敗時會噴錯誤訊息 (可使用 beging rescure 捕捉) R first 找出第一筆資料 last 找出最後一筆資料 find:找出單一筆資料，且只能透過id去搜尋。找不到時 find 會噴錯誤訊息 (例外訊息) find_by 找出單一筆資料，且可以透過自訂條件去搜尋。找不到時 find_by 會回傳的值是nil find_each 資料量大時，預設每次抓 1000 筆 all 找出所有資料 select(’name’) 同上，但只選取 name 欄位 where(name: ‘Happy’) 找出所有 name 欄位是 Ruby 的資料 order(‘id DESC’) 依照 id 大小反向排序 order(id: :desc) 同上 limit(3) 只取出 3 筆資料 count average sum maximum 與 minimum U update update_all increment 欄位的值 + 1 (沒有存檔功能，要記得 save) toggle 把原本的 true / false 值對調 (沒有存檔功能，要記得 save) D delete destroy 刪的過程中，有一連串的 callback destroy_all\nScope\n把商業邏輯寫到 model 裡 取代 controller 一堆 where 是一種類別方法\n八、 MVC\nMVC 架構 Model View Controller\n流程: 一個使用者，透過 route(第一線處理 request 的角色，在 rails 裡非常重要) 導到某一個controller，也許需要調資料(跟model)，也許不用。查完之後(如果需要查詢的話)把資料交還給controller，用 view 去做頁面呈現 (HTML \u0026 CSS)\nModel: 抽象層的概念 model 不是資料表，資料表是 table (實體存在的東西)\nController: 本身是一個 class ， 一個一個的 action 就是方法\nView: 在 controller acton (透過 model 向資料庫) 拿到的 raw data，搭配畫面跟表單，組成一般使用者可以讀的表格、表單\n優點∶ 歸類整齊，易於前後端分工 流程控制: controller 資料邏輯: model 畫面相關: view\n View 技術上來說，其實是會回傳 HTML 內容的方法(method、function)\n 九、資料驗證 前端驗證: 還沒送出去前，在表單用 JavaScript擋下來，缺點驗證是容易被避開 後端驗證: 寫進資料庫之前，如果內容沒填、格式有問題等，把它擋下來。\n在 model 層，比如名字欄位必填，可以使用以下的驗證器\n1  validates :name, presence: true   其他在 rails guide 的 Validation Helpers 還有更多可以使用的驗證\n不寫在 controller 的原因，每一個 controller 要寫去都要做檢查\nmodel 是整包做檢查\n 若同時有不同系統存取資料庫的狀況(比如PHP)，則無法保證資料一定無誤。這時可以在資料庫本體擋掉，比較安全\n  如何繞過驗證 c.save(validate: false)\n 十、 Callback\n資料存檔的流程會經過以下流程: save \u003e valid \u003e before_validation \u003e validate \u003e after_validate \u003e before_save \u003e before_create \u003e create \u003e after_create \u003e after_save \u003e after_commit\nbefore_save 資料寫進跟更新都會執行 before_create 資料被建立的時候才會執行\n十一、 Active Record\n是一種設計模式，本身是一個物件。 每一筆資料包裝成一個物件，並在其增加資料操作邏輯，讓資料的存取更便利\n這個物件，由欄位、基本操作、商業邏輯組成\n我們可以說 MVC 裡的 Model = 依照 Active Record 模式設計的產物\n而 Active Record 是一種 ORM 框架\nActive Record ORM Model Database Table\n十二、二大哲學 (一) 慣例優於設定 Convention Over Configuration(CoC) 慣例 = 可以少寫不必要的程式碼 學習 Rails ，等於是在學習 Rails 的慣例 例如:\n Model: 大寫、單數 Table: 小寫、複數 每個表格預設會有一個叫做 id 的流水編號欄位 在 migration 裡預設會有個 timestamps，在具現化的時候，會轉換成 created_at updated_at這兩個時間欄位，在資料新增或更新的時候自動寫當下時間 model 跟 table 的對應 pluralize 找出複數名詞的方法 singularize 找出單數名詞的方法 比如  \"person\".pluralize =\u003e \"people\" \"people\".singularize =\u003e \"person\"  若需自定義，在config/initializers/inflections.rb設定\n 檔案跟 model 的對應。類別名稱由兩個以上的單字組成時，Model 名稱應要遵循 Ruby 的命名慣例，採用駝峰式命名，而資料表名稱必須採用底線分隔。 underscore變成蛇式的方法 camlize變成駝峰式 比如  \"HappyHour\".underscore =\u003e \"happy_hour\" \"happy_hour\".camlize =\u003e \"HappyHour\" 外鍵 - 應用資料表的單數形加上 _id 來命名，比如 item_id, order_id。Active Record 會在你建立 Model 之間的關聯時，尋找這種形式的欄位 singularized_table_name_id。  當 model 之間的關連不是用慣例時，必須加上 foreign_key\n比如有一個 store 的 model:\n1  belongs_to :owner #foreign_key: 'owner_id'   foreign_key 是遵循慣例，所以後面可以省略，但如果是接手別人案子或設計，可能原本不是用 ruby 或 rails 寫的，則需寫出 foreign_key 如下\n1  belongs_to :owner foreign_key: 'u_id'    主鍵(流水編號欄位id) - Active Record 預設會使用一個叫做 id 的整數欄位，作為資料表的主鍵。採用 Active Record migration 來建立資料表時，這個欄位會自動產生。\n  參照值\n  user:references 會造出 user_id 這個數字型態欄位 會指向 user 這個 model 的主鍵(流水編號欄位id)\n(二) Don’t repeat yourself\n十三、關聯性\n一對一、一對多、多對多 has_one 不是設定，它是一個類別方法，例子中的 store 是它的參數 執行 has_one 後，會動態做出四個方法，比如\n1 2 3 4 5 6 7  has_one :store #做出以下的方法 #store #store= #build_store(不會直接寫進資料庫) #create_store    1 2 3 4 5  belongs_to :owner #做出以下的方法 #owner #owner=   1 2 3 4 5 6 7  has_many :books #做出以下的方法 #books #books= #build #create   十四、 include、extend、reuqire、load\nrequire,load用於檔案，如.rb等等結尾的檔案。include,load則用於包含一個檔案中的模組 include是引用模組內的方法來擴充實體方法，而extend則是擴充類別方法\n十五、API\n十六、RESTful\n十七、CACHE 暫存\n十八、 Active Job 背景工作\n十九、 前端的 partial 和 helper 差別\n二十、Gemfile 的用意？\n二十一、 namespace\n","description":"","tags":null,"title":"Ruby on Rails 面試題準備","uri":"/posts/interview/"},{"categories":null,"content":"LICEcap可錄製畫面直接存成gif 在專案的使用上非常方便，可以馬上呈現出你製作的功能，讓一起開發的組員一目瞭然。\nMac跟Windows都可以使用 官網下載\nMac使用者記得下載後，到 系統偏好設定 -\u003e 安全性與隱私權 -\u003e 螢幕錄製 裡\n把LICEcap打勾(反灰不能編輯時請按視窗左下角的鎖頭，即可登入權限編輯)\n","description":"","tags":null,"title":"好用工具 LICEcap","uri":"/posts/licecap/"},{"categories":null,"content":"多國語系設置 step. 1 更改預設\nRails 支持多國語系(Internationalization，簡稱I18n)，預設的語系是英文，如要修改，請至config/application.rb\n1 2  config.i18n.available_locales = [:en, :'zh-TW'] #支援語系 config.i18n.default_locale = :'zh-TW' #預設語系   step. 2 新增詞匯檔\n接著，在config/locales新增zh-TW.yml 這個詞匯檔\n1 2  zh-TW:welcome:\"歡迎\"  修改首頁index.html如下\n1  \u003ch1\u003e\u003c%= t('welcome') %\u003e\u003c/h1\u003e   便可以看到首頁的\"welcome\"變成\"歡迎\"\n 檔案副檔名YML是一種YAML Document，格式的縮排必須使用兩個空格\n step. 3 新增Gem\n在Gemfile新增gem \"rails-i18n\" 接著bundle install\nstep. 4 Model字段翻譯\n1 2 3 4 5 6 7 8 9  zh-TW:welcome:\"歡迎\"activerecord:models:feedback:\"回饋\"attributes:feedback:author:\"你的名字\"message:\"訊息\"  就有英文介面及中文介面\nstep. 4 切換多國語系\n 在app/controllers/application_controller.rb新增以下這段  1 2 3 4 5 6 7 8 9 10 11  before_action :set_locale def set_locale if params[:locale] \u0026\u0026 I18n.available_locales.include?( params[:locale].to_sym ) session[:locale] = params[:locale] end I18n.locale = session[:locale] || I18n.default_locale end   接著在app/views/layouts/application.html.erb新增路徑  1 2  \u003c%= link_to \"中文版\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"zh-TW\" %\u003e \u003c%= link_to \"English\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"en\" %\u003e   就可以在頁面看到中文版跟英文版的切換了！\n","description":"","tags":null,"title":"Rails I18n","uri":"/posts/rails_i18n/"},{"categories":null,"content":"用Rails串接第三方支付 MVC\nM = Model 產生訂單的邏輯，比如\n  驗證 validates(使用者名字、金額、訂單編號username 、amount、 order_no)\n  before_create 在本例中是定義build_order_no這個方法\n  enum 在本例中是使用在付款方式的值設定pay_type)\n  V C = Controller 流程控制(產生東西、做什麼事情)\n before_create : 在 rails model 的callback，代表這筆資料被建立的時候我要做什麼事情，呼叫什麼方法。接著可以自己定義方法來使用。 enum : 列舉\n ","description":"","tags":null,"title":"Rails Payment Gateway","uri":"/posts/rails_payment_gateway/"},{"categories":null,"content":"在 rails 上使用 devise 套件 step 1. 在Gemfile加上\ngem 'devise' 或是在該目錄的終端機使用指令% bundle add 'devise'\nstep 2.\n% bundle install step3.\n% rails g devise:install 就會幫我們生成兩個在config下面的檔案\nconfig/initializers/devise.rb config/locales/devise.en.yml 接著在終端機的畫面同時顯示需要完成的指令:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  Some setup you must do manually if you haven't yet: 1. Ensure you have defined default url options in your environments files. Here is an example of default_url_options appropriate for a development environment in config/environments/development.rb: config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } In production, :host should be set to the actual host of your application. 2. Ensure you have defined root_url to *something* in your config/routes.rb. For example: root to: \"home#index\" 3. Ensure you have flash messages in app/views/layouts/application.html.erb. For example: \u003cp class=\"notice\"\u003e\u003c%= notice %\u003e\u003c/p\u003e \u003cp class=\"alert\"\u003e\u003c%= alert %\u003e\u003c/p\u003e 4. You can copy Devise views (for customization) to your app by running: rails g devise:views   一步一步的按照指令完成。\nstep 4.\n% rails g devise User 這個指令會幫我們生成一個migration檔 (db/migrate/20220423155313_devise_create_users.rb) 以及一個新的model檔(app/models/user.rb), 還有在routes.rb新增路徑divise_for :users\nstep 5. 更新資料庫\n% rails db:migrate step 6. 確認路徑\n% rails routes 找出user的路徑\n% rails routes | grep user 可以看到各路徑對照的行為，比如:\n1 2 3  new_user_session (sign_in) destroy_user_session (sign_out) new_user_registration (sign_up)   step 7. sign_up\n在終端機輸入rails s\n開啟http://localhost:3000/users/sign_up 就可以看到註冊頁面了\nstep 8. 清掉cookies\n註冊之後，因為目前的頁面還沒有做sign_out的連結，所以再輸入一次http://localhost:3000/users/sign_up會看到訊息:You are already signed in. 這時候的你，可以打開開發者工具中的Application的Cookies，把該檔案名稱對應的值刪掉，就可以清掉記錄進入到sign_up頁面\nstep 9. Bulma\n參考https://bulma.io/documentation/overview/ 下載Bulma，把樣式表插入app/views/laywout資料夾中的application.html.erb\n1  \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css\"\u003e   接著還要在同個檔案新增meta tag\n1  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e   step 10. 新增navbar 在 app/views 新增shared資料夾，並在裡面新增_navbar.html.erb檔，接著回到laywout的application.html.erb，在body的地方把剛剛的檔案渲染。\n1  \u003c%= render 'shared/navbar' %\u003e   step 11. 編輯navbar\n回到_navbar.html.erb檔，把BULMA的Basic Navbar樣式貼上去，再按照自己的需求編輯:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cnav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\"\u003e \u003cdiv class=\"navbar-brand\"\u003e \u003ca class=\"navbar-item\" href=\"https://bulma.io\"\u003e \u003cimg src=\"https://bulma.io/images/bulma-logo.png\" width=\"112\" height=\"28\"\u003e \u003c/a\u003e \u003ca role=\"button\" class=\"navbar-burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"navbarBasicExample\"\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e (過長省略，程式碼在: https://bulma.io/documentation/components/navbar/)   step 12. 新增sign_up、sign_out、sign_in連結在_navbar.html.erb檔\n1 2 3 4 5 6 7 8 9  \u003c% if  user_signed_in? %\u003e \u003c%= link_to 'Sign out', destroy_user_session_path, method: :delete, class: \"button is-primary\" %\u003e \u003c% else  %\u003e \u003c%= link_to 'Sign up', new_user_registration_path, class: \"button is-primary\" %\u003e \u003c%= link_to 'Log in', new_user_session_path, class: \"button is-light\" %\u003e \u003c% end %\u003e   step 13. 在首頁印出登入者資料\n1 2 3  \u003c% name  = current_user.present? ? current_user.email : '訪客' %\u003e \u003ch1\u003eWelcome, \u003c%= name %\u003e\u003c/h1\u003e   到這邊為止，就可以看到一個基本的登入頁面了。\n 參考資料:https://youtu.be/jd1gOhpETIA\n ","description":"","tags":null,"title":"Ruby on Rails devise","uri":"/posts/ruby_on_rails_devise/"},{"categories":null,"content":"候選人票選系統純手工打造 ．基本新增修改刪除介紹\n．使用vscode編輯\n．參考資料: 為你自己學Ruby On Rails\n00 開始之前 step 1. 使用指定Rails版本生成專案:\nrails _版本_ new 專案名\n% rails _6.1.5_ new hello_rails step 2. 進到該資料夾 cd hello_rails git版控初始化 git init\nstep 3. 第一次commit git add . git commit -m\"init commit\"\nstep 4. 確定環境正常運作 rails s 進到localhost:3000確認畫面\n01處理Route，新增(建立)路徑 step 1. 找到Route檔 confing -\u003e routes.rb (或是使用ctrl+p搜尋)\nstep 2. 做出候選人相關資源/路徑 在routes.rb檔案裡輸入\n1  resources :candidates   rails routes可查看路徑對照表 可看到做出的八條路徑，對應到七個action\ncandidates#index candidates#create candidates#new candidates#edit candidates#show candidates#update candidates#update candidates#destroy 若只想做出特定路徑，如index跟show，示範如下\n1  resources :candidates, only: [:index, :show]   step 3.新增controllers app -\u003e controllers 按右鍵新增檔案\ncandidates_controller.rb 接著，在檔案裡面輸入\n1 2 3 4 5  class CandidatesController \u003c ApplicationController def index end end   step 4. 新增view app -\u003e views 按右鍵新增資料夾\ncandidates 在candidates裡再新增檔案\nindex.html.erb 輸入\n1  \u003ch1\u003eHi\u003c/h1\u003e   這時，就可以在\nlocalhost:3000/candidates 看到剛剛輸入的Hi了\nstep3-step4手工打造的部分，可使用指令\n% rails g controller candidates 02 新增Model step 1.使用指令新增model\n要先想一下Candidate的Model要有哪些欄位及其對應的資料型態\nModel不等於資料庫/資料表，是一個抽象層的概念\n這個過程如果要純手工，會涉及到需手動建立migration檔來描述這個資料表要長什麼樣子，需要寫一些語法，對現階段的我們來說會有點吃力，建議直接使用指令\n% rails g model Candidate name:string party:string age:integer politics:text votes:integer 如果是文字型態(string)，可省略不寫\n% rails g model Candidate name party age:integer politics:text votes:integer 這個指令會幫你做兩件事\n 建立candidate這個model 會根據你給它的欄位，建位一個migration(主要目的)  慣例:如果model叫Candidate(大寫單數)，資料表migrate中的表格table就會是candidates(小寫複數)\nstep 2.描述檔具現化\n% rails db:migrate 會在 db 這個資料夾建立檔案 檔案名為:\ndevelopment.sqlite3 在rails預設使用的資料庫就是sqlite，它是一種檔案型的資料庫，效能不好，但簡單易用，以練習來說還算堪用，在我們這次開發過程中所有資料都會寫到這裡。\n在config/database.yml裡的adapter可以確認本次專案所使用的資料庫系統\n在不同的環境(開發、測試)，會存放在不同的資料庫\n例如 開發:\ndatabase:db/development.sqlite3 測試:\ndatabase:db/test.sqlite3 03 新增候選人表單 step 1. 確認表單路徑\n在\n% rails routes 找到\ncandidates/new step 2. 寫入連結 回到00章節中 step4 裡在candidates建立的index，在裡面寫入\n1  \u003ca href=\"/candidates/new\"\u003eAdd Candidate \u003c/a\u003e   就可以在\nlocalhost:3000/candidates 頁面看到我們設定的超連結了。但這時點下去這個超連結，應該會出現在錯誤訊息，因為我們還沒有做出相對應的action給它。\nstep 3.定義 new action 回到\ncandidate_controller.rb 定義 new action\n1 2  def new end   step 4. 做出 new 的view\n在views -\u003e candidates 新增檔案\nnew.html.erb 輸入\n1  \u003ch1\u003eAdd Candidate\u003c/h1\u003e   就可以在localhost:1313/candidates/new看到這行新增履歷的文字了\n03-1 手刻建立表單 step 1. 建立 form 表單，使用POST方法\n在 new.html.erb 檔裡寫入\n1 2 3 4  \u003cform action=\"candidates(要去什麼地方)\" method=\"POST(用什麼方式送)\"\u003e \u003cinput type=\"text\" name=\"abc\"\u003e \u003cinput type=\"submit\" value=\"go!\"\u003e \u003c/form\u003e   這邊要稍微記一下(或是可以參考路徑對照表)，在我們從candidates/new這邊，用POST方法往candidates送，那接著就會要找create這個action\ncandidate#create step 2.定義create action 回到\ncandidate_controller.rb 定義 create action\n1 2  def create end   step 3. 認識rails預設的保護機制\n為避免票務或其他相關設計的灌水問題，在使用form表單要往某個地方送的時候，rails會要求要有 authenticiy token。我們可以用以下的 ruby 方法\u003c%= form_authenticity_token %\u003e讓每次載入頁面時，會生出一段authenticity token。按下送出時這段token就會跟著表單一起送到 action。目的是要透過由我們發出去的 authenticity token 來確認用戶是從我們網站進來的，進而達到避免有心人士使用自己寫的程式來不停送出(票數)灌水。\n1  \u003cinput type=\"hidden\" name=\"authenticity_token\" value=\"\u003c%= form_authenticity_token %\u003e\"\u003e   03-2 使用form_for小幫手 在rails裡，有個叫form helper的小幫手，使用它來幫助我們建立表單。就不用像03-1過程這麼繁瑣。\nstep 1. 使用form_for form for 是為了某個model建立表單, 語法如下form_for(model) ，套用在我們這次的實作，因為Candidate是一個class，所以我們在後面加上.new，讓它變成一個model。並把它定義在candidates_controller.rb的new裡。並給它一個實體變數(@)，view才能拿的到。\n(之所以要把model定義在controller裡，是因為在 MVC 結構裡，view 的角色就是單純把東西印出來，不要做產生物件或邏輯運算之類的事，屬於被動角色)\n1 2 3  def new @candidate = Candidate.new end   回到candidates/new，把定義好的實體變數接在form_for裡\n\u003c%= form_for(@candidate) %\u003e form_for 發現後面接的是全新的model的時候，會幫你長出相對應的路徑、方法包含token全部寫完。\nstep 2. 搭配 ruby 的 程式碼區塊(Block) 搭配 ruby的程式碼區塊(Block)do end加上小幫手的.text_field方法來產生欄位，及.label方法來做出標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c%= form_for(@candidate) do |form| %\u003e \u003c%= form.label :name %\u003e \u003c%= form.text_field :name %\u003e \u003c%= form.label :party %\u003e \u003c%= form.text_field :party %\u003e \u003c%= form.label :age %\u003e \u003c%= form.text_field :age %\u003e \u003c%= form.label :politics %\u003e \u003c%= form.text_area :politics %\u003e \u003c%= form.submit %\u003e \u003c% end %\u003e   03-3 create action step 1. 得到parameters params 是一個方法會回傳 ActionController::Parameters 物件，在實務上會像一個 hash。所以我們可以透過params來取得parameters。\n在 03-2 把表單建立好，按下送出之後，在 log 中可以發現一包參數(parameters)，裡面包含token、欄位所填的資料 ，我們就可以透過params這個hash，使用candidate這個key來取得相對應的一包hash(value)\n1  params[:candidate]   丟給Candidate.new這個model。接著使用(@)實體變數建立物件，叫這個物件存檔(save)。如果成功，就把頁面導向候選人列表頁。 如果失敗，使用 render 這個方法，借 new 的頁面重新渲染。render :new\n1 2 3 4 5 6 7 8 9  def create @candidate = Candidate.new(params[:candidate]) if @candidate.save redirect_to '/cnadidates' else render :new end end    補充說明 1:hash是什麼? hash是由key、value所組成的資料，設計者只要根據Key值就可以取得相對應的資料。 如何建立hash？ 1.使用hash類別，new一個給他。\nuser = Hash.new\n2.使用大括號 user = { name: ‘Judy’, age:8 }\n  補充說明 2:製造巧合 在 new 及 create 取了一樣的實體變數名字，讓render :new 可以順利在空中抓取資料並透過form_for讓值擺放在相對應的欄位。\n def new @candidate = Candidate.new end def create @candidate = Candidate.new(candidate_params) end step 2. 清洗params 當我們試圖要把整包hash的資料透過 model 寫進資料庫的時候，model會發現這包網路上抓下的東西還沒清洗(過濾檢查)過(使用者可以很輕易的在頁面上編輯加欄位)。預設會擋下來。 使用 require 這個方法，抓取candidate並使用permit只允許部分欄位過來。\n1  params.require(:candidate).permit(:name, :party, :age, :politics)   接著，設定一個變數名稱給它，或是知道我們後面會很常再使用它，可以直接定義方法。再把它放進Candidate.new這個model。\n第一個方式如下:\n1 2 3 4 5 6 7 8 9 10 11  def create clean_params = params.require(:candidate).permit(:name, :party, :age, :politics) @candidate = Candidate.new(clean_params) if @candidate.save redirect_to '/cnadidates' else render :new end end   第二個方式，把它單獨定義一個方法，讓它可以被重複使用，因為不需被外部存取，可以加入 private 註記，變成私有方法。是一個比較好的作法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def create @candidate = Candidate.new(candidate_params) if @candidate.save redirect_to '/candidates' else render :new end end private def candidate_params params.require(:candidate).permit(:name, :party, :age, :politics) end   step 3. 確認存取的資料 在rails console或 rails c輸入\nCandidate.all 就可以印出目前Candidate這個表格裡的所有候選人\nstep 4. 使用者提示 flash flash 是快閃訊息的意思，只要印在畫面一次之後，就會消失。\nflash 本質上就是一個hash。key的慣例上會使用notice，後面再接上要給的訊息。寫的方式如下:\n1  flash[:notice] = \"Candidate created\"   接著，就在要印出這個flash的html頁面寫入\n1  \u003c%= flash[:notice]%\u003e   03-4 加入驗證 在 app -\u003e models 裡的 candidate.rb 檔，根據我們的驗證條件寫入 validates\n1 2 3  calss Candidate \u003c ApplicationRecord validates :name, present:true end   03-5 撈出候選人列表 我們已經順利把候選人寫入資料庫了，現在要把資料撈出來。在candidates_controller.rb這裡透過 Candidate 這個 model 的類別方法 all Candidate.all\n1 2 3  def index @candidates = Candidate.all end   並且在index.html.erb這個檔案裡用table，搭配使用ruby的迴圈each把候選人資料一筆一筆印出來\n03-6 link_to View-helper小幫手link_to\n1  \u003c%= link_to '要秀出來的字樣', '要去的位置'%\u003e   第二種寫法，使用路徑 Prefix 提供的名稱加上 _path\n1  \u003c%= link_to '要秀出來的字樣', new_cnadidate_path %\u003e   第二種寫法的優點  拼錯就會馬上噴錯 之後更改路徑名稱方便  所以盡量以第二種寫法為主。\n03-7 show action step 1. 重覆之前在controller定義action的方式定義show action。注意不要放在private底下。\n1 2  def show end   step 2. 做出view show.html.erb\nstep 3. 透過params拿id欄位回來用\n透過params拿id欄位回來，再透過modle的find_by方法找某候選人的資料\n1  @candidate = Candidate.find_by(id: params[:id])   step 4. 在show.html.erb做列表，把find_by 找到的資料印出來，會根據不同的id而有不同的結果。\nstep 5. 加上 if 判斷 如果候選人有資料，就印出來，反之，印出no record\n1 2 3 4 5 6 7  \u003c% if  @candidate %\u003e #印出資料 \u003c% else %\u003e \u003ch1\u003e No Record Found \u003c/h1\u003e \u003c% end %\u003e    補充說明\n\u003c%= %\u003e 與 \u003c% %\u003e\n兩者的差別在於需不需要於畫面輸出，有加=的會印出來。\n 03-8 沒有通過驗證的錯誤訊息 step 1.透過any?來詢問有沒有任何錯誤訊息\n.errors.any? 這時，對照03-3的save，存檔過程中要是沒有通過驗證，就可以在\n.errors.any? 得到true的結果\n再使用full_messages來得到錯誤訊息\n.errors.full_messages 一樣搭配.each的方法來逐個印出資訊\n1 2 3 4 5 6 7  \u003c% if  candidate.errors.any? %\u003e \u003cul\u003e \u003c% candidate.errors.full_messages.each  do |message| %\u003e \u003cli\u003e\u003c%= message %\u003e\u003c/li\u003e \u003c% end  %\u003e \u003c/ul\u003e    補充說明 可以透過.method的方法來確認有什麼method可以使用\n step2. 修正版面 因為驗證沒有過而render :new 回來後，版面會因為被多了一層div(field_with_errors)包裏而跑掉，我們要怎麼處理呢？\n來到 app -\u003e assets -\u003e stylesheets 資料夾裡按右鍵開一個檔案candidate.scss。這個資料夾裡的所有css檔案可以透過同個資料夾的application.css(打包描述檔)裡的這個描述\n*= require_tree . 打包回來。\n接著，就可以在candidate.scss編輯想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .field_with_errors{ display: inline-block; input[type=\"text\"]{ border-color: red; border-width: 1px; } label { color: red; } }   04 修改(edit) 一樣使用前面提到的link_to來寫。\nstep 1. 確認路徑\n/candidates/:id/edit step 2. 確認Prefix\nedit_candidate step 3. 在index.html.erb寫入\n1  \u003c%= link_to 'update', edit_candidate_path(candidate.id) %\u003e    補充說明\n若Prefix的欄位是空白的，則對應的是前一個欄位\n 04-1 edit action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def edit @candidate = Candidate.find_by(id: params[:id]) end   step 2. 做出view edit.html.erb\nstep 3. 做一個表單\n(可用new.html.erb的內容來套用)\nstep 4. PATCH / UPDATE 接下來在瀏覽器按下update後，可以在log裡看到form_for幫我們產出的其中一個input，有patch這個方法。\n1  \u003cinput type=\"hidden\" name=\"_method\" value=\"patch\"\u003e   這是因為目前瀏覽器還沒有支援到那麼多的方法(動詞)，所以rails用這個方式\"假裝\"patch(實際上是post)\n由路徑對照表可以看到，如果是用PATCH的方法對/cnadidates/:id這個路徑去送的話，會對應到candidates#update這個方法。\n 補充說明 1.\nrails會根據那個modle是不是全新的來判斷(猜測)form.submit是要使用create還是update\n全新的物件 -\u003e create 從資料庫撈出來的 -\u003e update\n  補充說明 2. (1) 用GET的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#show這個方法 (2) 用PUT的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#update這個方法\n(3) 用DELETE的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#destroy這個方法\n 04-2 update action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def update @candidate = Candidate.find_by(id: params[:id]) end   step 2. 類似 create action 的作法，並且失敗的話，借edit的頁面來渲染 1 2 3 4 5 6 7 8 9 10  def update @candidate = Candidate.find_by(id: params[:id]) if @candidate.update(candidate_params) flash[:notice] = \"Candidate updated!\" redirect_to '/cnadidates' else render :edit end end   05 刪除 step 1. 確認路徑\n/candidates/:id step 2. 確認Prefix\ncandidate (沒寫的話的，為同上)\nstep 3. 在index.html.erb寫入\n1  \u003c%= link_to 'delete', candidate_path(candidate.id) %\u003e   step 4. 做出跟update的區別 到目前為止，因為跟update一樣路徑都是在/candidates/:id 所以要在 link_to 裡加幾個參數，讓它不會往show送\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete' %\u003e   在檢視原始碼的時候，就會發現多出data-mathod=\"delete\" 如此，在頁面上按下delete的時候，就會對該路徑使用delete這個動詞，接著往/cnadidates/:id這個路徑去送，會找到candidates#destroy這個方法\n05-1 destroy action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3 4 5 6 7  def destroy @candidate = Candidate.find_by(id: params[:id]) @candidate.destroy flash[:notice] = \"Candidate deleted!\" redirect_to '/candidates' end   step 2. 防呆機制 在index.html.erb裡的link_to加上確認data: {confirm:\"\"}\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete', data: { confirm: 'are you sure?' } %\u003e   如此，便可以在刪除資料的時候，跳出確認視窗\n06 錯誤訊息 錯誤訊息的解答通常都在訊息裡\n錯誤訊息:missing a template 代表缺少MVC裡的V(view)，需要在view裡建相對應的 html 給它\n錯誤訊息:Migrations are pending 代表還有一個migrations還沒處理，執行rails db:migrate就可以解決\n錯誤訊息:UnKnown action 代表缺少某個action，需要在 controller 裡定義\n錯誤訊息:Routing Error. No route matches 找不到路徑(有可能是還沒建或是路徑打錯字)\n錯誤訊息:InvalidAuthenticity Token 無有效的驗證\n錯誤訊息:ForbiddenAttributesError 還沒清洗params(還不是白名單)\n rails設計哲學之一就是慣例優於設定\n ","description":"","tags":null,"title":"Ruby on Rails CRUD","uri":"/posts/ruby_on_rails_crud/"},{"categories":null,"content":"環境相關 ruby rvm list 查看電腦裡已經安裝哪些版本的Ruby:\n% rvm list ruby-2.7.2 [ arm64 ] =* ruby-2.7.5 [ arm64 ] =* 符號表示目前正在使用的版本(同時也是目前預設的 Ruby 版本)\nruby -v 查看目前 Ruby 的版本:\n% ruby -v ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [arm64-darwin21] $ rvm use 切換到其他版本的Ruby，例如想要切換到 2.7.2 版本:\n% rvm use 2.7.2 use可省略，例如要切換回2.7.5版本:\n% rvm 2.7.5 --default可設定預設Ruby版本:\n% rvm 2.7.5 --default 這樣之後每次開終端機視窗就會自動切換到 2.7.5 版\nrails gem list 查看電腦裡已經安裝哪些版本的Rails:\n% gem list rails (7.0.2.3, 7.0.2.2, 6.1.5) 或者使用gem list | grep rails\nrails -v 查看目前 Rails 的版本:\n% rails -v Rails 7.0.2.3 gem install rails 安裝最新版本Rails\ngem install rails -v 版本 安裝指定Rails版本:\n% gem install rails -v 6.1.5 rails _版本_ new 專案名使用指定Rails版本生成專案:\n% rails _6.1.5_ new hello_rails ","description":"","tags":null,"title":"Ruby on Rails Environments","uri":"/posts/ruby_on_rails_environments/"},{"categories":null,"content":"JavaScript是一種動態型別的程式語言(Dynamically Typed Language)，使用變量(Variable)及常量(Constant)來儲存數據。變數可以先宣告，再賦值，如:\n1 2  let age age = 20   常數則否，一定要同時進行，如:\n1  const myage = 18   所謂動態型別的程式語言是指，在運行期間才做數據類型檢查的語言。即動態類型語言編緝程式時，永遠不用給任何變量指定數據類型。 該語言會在第一次賦值給變量時，在內部將數據類型記錄下來\n並且充許在運行周期裡，儲存不同類型的數據。 例如:\n1 2  let message = 2; //數值 message = \"Hello World\" //轉換成字串   命名方式  可使用包含字母、數字、$、_ 首字符不能是數字 使用駝峰式命名法(如:myName)  八大資料型別    原始型別(Primitive Type) 物件型別( Object Type)     Boolean Object   Null    Undefined    Number    Bigint    String    Symbol     使用typeof 運算子可以幫助你判斷型別，其中函式（function）和陣列（array）、日期（date）皆為物件(Object)的一種，function 是可呼叫的物件，而 array 是結構較嚴謹的物件。\nFunction 函數  函數是一個行為(action) 一般只執行一個功能 參數可以配默認值參數 = \"默認值\" 可以返回或不返回值，返回值時需使用return  Async Await promise的出現，目標是為了解決callback hell的現象，而Async Await則是為了讓非同步執行變得更簡潔，更直觀\ncallback -\u003e promise -\u003e Async Await\n特點:\n 更貼近同步執行程式碼 概念是由promise基礎上演變 Async Await會返回promise object Await關鍵字只能在Async function裡使用，必須尾隨promise object 使用try catch語句捕捉Async Await出現的錯誤  ","description":"","tags":null,"title":"Beginner JavaScript Notes","uri":"/posts/java_script_notes/"},{"categories":null,"content":"陣列的 map、filter 跟 reduce 三個常用的方法介紹 在介紹這三個方法之前，先帶大家了解何謂\"callback function\"。\n引用 MDN 的說明如下:\n 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。它會在外部函式內調用，以完成某些事情。\n 簡單來說，就是一個程式執行完再去執行另一個程式，並且是在指定時機才觸發的。\n接著我們來看這三個方法在 W3Schools 中的說明\n map() Creates a new array with the result of calling a function for each array element\n  語法let new_array = arr.map(function callback( currentValue[, index[, array]]) {// return element for new_array}[, thisArg])\n  filter() Creates a new array with every element in an array that pass a test\n  語法var newArray = arr.filter(function callback(element[, index[, array]])[, thisArg])\n  reduce() Reduce the values of an array to a single value (going left-to-right)\n  語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n 根據語法我們可以發現這三個方法都是 callback function。\n翻成中文的意思大概如下:\nmap() 方法會建立一個新陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\nfilter() 方法會建立一個每一個元素經過指定運算判斷後回傳為真的新陣列。\nreduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。\nreduce 方法跟 map、filter 的差別是它會 return 一個值，而不是一個新陣列，這會連帶使 reduce 的語法結構跟邏輯與其他方法不太相同。\n看起來有點複雜，其實就是使用 callback 函式處理陣列中的每個元素，可傳入以下四個參數，我們再對照語法來看一次:\n 語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n  accumulator：累加器;經由個別 currentValue 加總的累計值 currentValue：Array 正在處理的元素 currentIndex(選擇性)：正在處理的元素索引 array(選擇性)：原始陣列  initialValue(選擇性)：初始值(預設值)，放在 function 的最後方，於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。\n","description":"","tags":null,"title":"filter, map and reduce in JS","uri":"/posts/java_script_method/"}]
