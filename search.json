[{"categories":null,"content":"Ruby Blocks In Ruby, a block is an anonymous code block that can be passed as a parameter to a method or used with iterator methods. A block can be seen as a reusable piece of code that can be called and executed when needed.\nThe role of blocks in Ruby includes:\nIterators: Many Ruby methods allow you to pass a block as a parameter to iterate over or process elements during the execution of the method. For example, the each method can be used to iterate over each element in an array, and the times method can repeat a specified number of times.\nAnonymous Functions: Blocks can be used to create anonymous functions and pass them as parameters to other methods. This allows us to define our own program logic in the appropriate context, enabling more flexible functionality.\nCallbacks: Blocks can be invoked as callback functions when specific events occur. When certain conditions are met, you can call the block to execute the corresponding code. This is particularly useful in event-driven programming, asynchronous operations, or custom callback mechanisms.\nBy using blocks, you can manipulate code and data more flexibly and pass and execute your own program logic when needed.\n在 Ruby 中，block（區塊）是一種匿名的程式碼塊，可以作為參數傳遞給方法或者使用迭代器方法。block 可以被視為一段可重複使用的程式碼，它可以在需要時被呼叫和執行。\nblock 在 Ruby 中的作用如下：\n迭代器（Iterators）：許多 Ruby 方法允許你傳遞一個 block 作為參數，以便在方法的執行過程中進行迭代或處理。例如，each 方法可以用於遍歷陣列中的每個元素，而 times 方法可以重複執行指定次數的程式碼。\n匿名函式（Anonymous Functions）：block 可以用於創建匿名函式，並將其作為參數傳遞給其他方法。這使得我們可以在適當的上下文中定義自己的程式邏輯，以實現更靈活的功能。\n回呼（Callbacks）：block 可以在特定事件發生時被調用，作為回呼函式。當特定條件滿足時，你可以呼叫該 block 以執行相應的程式碼。這在處理事件驅動的程式設計、非同步操作或自訂回呼機制時非常有用。\n透過使用 block，你可以更靈活地操作程式碼和資料，並在需要時傳遞和執行自己的程式邏輯。\nBlock vs Method In general, a method is a named and defined functionality in code that can be called multiple times at various places. On the other hand, a block is an anonymous piece of code that is often closely associated with a method and can be passed and invoked during the execution of the method. Blocks are commonly used for implementing iterators, callbacks, and customizing logic during method invocation.\nHere are the key differences between methods and blocks:\nDefinition and Invocation: Methods are defined and named in the code, and they are called by using their names. Blocks, on the other hand, are anonymous and can be directly passed and invoked during method calls without being explicitly defined or named.\nScope: Methods have their own scope and lifecycle. They can be called multiple times in the code. Blocks, on the other hand, are closely tied to a method and exist only during the execution of that method.\nParameter Passing: Methods can accept parameters, and these parameters can be accessed within the method. Blocks can also accept parameters, usually passed using the yield statement or the \u0026 symbol, depending on the implementation of the method.\nControl Flow: Methods can use the return statement to return a value from the method. They can also use break and next to control the flow of execution. Blocks, when invoked, can affect the control flow of the method or iteration using return, break, and next statements.\nIn summary, methods are named and defined functionalities in code that can be called multiple times. Blocks, on the other hand, are anonymous pieces of code that are often associated with methods and can be passed and invoked during the execution of the method. Blocks are commonly used for implementing iterators, callbacks, and customizing logic during method invocation.\n在Ruby中，block和方法（method）之間有一些重要的區別，包括以下幾點：\n定義和調用方式：方法可以在程式碼中定義並命名，然後通過名稱進行調用。而block是一段匿名的程式碼，可以在方法調用時直接傳遞，而不需要事先定義名稱。\n作用範圍：方法具有自己的作用範圍和生命週期，可以在程式中多次調用。而block是與方法緊密結合的程式碼片段，它的生命週期僅在方法的執行期間存在。\n參數傳遞：方法可以接受參數，並且在方法內部可以訪問這些參數。block通常也可以接受參數，但它通常是使用yield語句或者\u0026符號進行傳遞的，具體取決於方法的實現。\n控制流程：方法可以使用return語句從方法中返回值，並且可以在程式碼中使用break和next控制流程。block可以在方法內部根據需要被調用，並且可以使用return、break和next來影響方法或者迭代的控制流程。\n總的來說，方法是在程式碼中定義的命名功能，可以在需要的地方多次調用。而block是一段匿名的程式碼，通常與方法緊密結合，可以在方法的執行期間被傳遞並調用。block通常用於實現迭代器、回呼和在方法調用時定制程式邏輯等場景。\n","description":"","tags":null,"title":"Ruby_blocks","uri":"/posts/ruby_blocks/"},{"categories":null,"content":"Static and Dynamic languages Static and dynamic languages are two different ways of classifying programming languages. Here are their representatives and respective advantages and disadvantages:\nRepresentatives of static languages: Java, C++, C# Static languages require variables, functions, and objects to have their type determined at compile time, and perform type checks on these types at runtime. This approach can catch some common errors at compile time, thereby increasing code reliability and security.\nAdvantages: Common errors can be caught at compile time, increasing code reliability and security. More stringent type checks can reduce the chances of code errors. Better code optimization can be performed, improving code execution efficiency.\nDisadvantages: Type determination of variables, functions, and objects must be performed at compile time, which may increase development costs and time. Code may become more verbose, requiring more type declarations.\nRepresentatives of dynamic languages: Python, Ruby, JavaScript Dynamic languages do not require variables, functions, and objects to have their type determined at compile time, but rather dynamically determine these types at runtime. This approach makes code more flexible and easier to develop.\nAdvantages: Code can be more flexible and easier to develop. Code can be more concise, without requiring large amounts of type declarations. Testing and debugging can be easier.\nDisadvantages: Because strict type checking is not performed, some errors can be more easily introduced, which may only be discovered at runtime. Execution efficiency may be lower, as type checking and optimization are not performed.\n靜態語言和動態語言 靜態語言和動態語言是兩種不同的程式語言分類方式，以下是它們的代表以及各自優缺點：\n靜態語言的代表：Java、C++、C# 靜態語言需要在編譯時期就確定變數、函數和物件等的型別，並在運行時期執行這些型別的檢查。這種方式可以在編譯時期捕捉到一些常見的錯誤，從而提高代碼的可靠性和安全性。\n優點： 可以在編譯時期捕捉到一些常見的錯誤，從而提高代碼的可靠性和安全性。 可以對代碼進行更嚴格的型別檢查，從而減少代碼出錯的機會。 可以進行更好的代碼優化，提高代碼執行效率。\n缺點： 需要在編譯時期就確定變數、函數和物件等的型別，這可能會增加一些開發成本和時間。 代碼可能會變得較為冗長，需要添加更多的型別聲明。\n動態語言的代表：Python、Ruby、JavaScript 動態語言不需要在編譯時期確定變數、函數和物件等的型別，而是在運行時期動態地確定這些型別。這種方式可以讓代碼更加靈活和易於開發。\n優點： 可以讓代碼更加靈活和易於開發。 代碼可以更為簡潔，不需要添加大量的型別聲明。 可以更加容易地進行測試和調試。\n缺點： 由於不進行嚴格的型別檢查，容易出現一些錯誤，需要在運行時期才能發現。 由於不進行型別檢查和優化，執行效率可能較低。\n","description":"","tags":null,"title":"Static and Dynamic languages","uri":"/posts/static_and_dynamic_languages/"},{"categories":null,"content":"The main difference between TypeScript and JavaScript is that TypeScript is a static type language, while JavaScript is a dynamic type language.\nSpecifically, TypeScript has the following features:\n  Type annotations: TypeScript allows type annotations to be added to variables, parameters, functions, objects, etc., clearly specifying the type of each value, thereby improving code readability and maintainability.\n  Type inference: TypeScript can automatically infer the type of each value based on the code context, simplifying the coding process.\n  Static checking: TypeScript performs static checking on the code during compilation, which can catch many common errors and improve code reliability and security.\n  Support for the latest JavaScript syntax: TypeScript supports the latest JavaScript syntax, such as ES6, ES7, and ES8, allowing developers to use the latest language features to write code.\n  Overall, TypeScript enhances code readability, maintainability, and reliability by adding a type system and static checking, and also makes it easier for developers to use the latest JavaScript language features.\nTypeScript 跟 JavaScript 最主要的差異在於 TypeScript 是一種靜態類型語言，而 JavaScript 是一種動態類型語言。\n具體而言，TypeScript 具有以下特點：\n  型別註解：TypeScript 可以在變數、參數、函數、物件等處添加型別註解，明確指定每個值的型別，從而提高了代碼的可讀性和可維護性。\n  型別推斷：TypeScript 可以根據代碼上下文自動推斷出每個值的型別，簡化了代碼的撰寫過程。\n  靜態檢查：TypeScript 在編譯時對代碼進行靜態檢查，可以捕捉到許多常見的錯誤，從而提高了代碼的可靠性和安全性。\n  支持最新的 JavaScript 語法：TypeScript 支持最新的 ES6、ES7、ES8 等 JavaScript 語法，可以讓開發人員使用最新的語言特性來編寫代碼。\n  總的來說，TypeScript 通過增加類型系統和靜態檢查等特性，可以提高代碼的可讀性、可維護性和可靠性，同時也能夠讓開發人員更加輕鬆地使用最新的 JavaScript 語言特性。\nStatic and Dynamic languages \n","description":"","tags":null,"title":"JavaScript vs TypeScript","uri":"/posts/typescript_vs_javascript/"},{"categories":null,"content":"Example 1 (SRP) Single Responsibility Principle (SRP)：單一職責原則\nThe Single Responsibility Principle (SRP) suggests that each class or module should have only one responsibility. Here’s an example:\nSRP 建議每個類別或模組應該只負責單一的職責。以下是一個範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 不符合 SRP 的範例 class Customer def initialize(name, email, phone) @name = name @email = email @phone = phone end def save_to_db # 保存顧客信息到數據庫 end def send_email # 發送電子郵件給顧客 end end   The above code violates SRP because the Customer class has two responsibilities - saving customer information to the database and sending an email to the customer. Here’s an example of how we can modify the code to adhere to SRP:\n上面的代碼違反了 SRP，因為 Customer 類別負責了兩個職責，即保存顧客信息到數據庫和發送電子郵件給顧客。以下是符合 SRP 的修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Customer def initialize(name, email, phone) @name = name @email = email @phone = phone end def send_email(customer) # 發送電子郵件給顧客 end end class AccountManagment def save_to_db # 保存顧客信息到數據庫 end end   Example 2 (OCP) Suppose we have a Payment class that handles payment operations. The class currently supports two payment methods:\n假設我們有一個 Payment 類別，它用於處理付款操作。該類別目前支持兩種付款方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Payment def initialize(amount, payment_method) @amount = amount @payment_method = payment_method end def process_payment if @payment_method == \"credit_card\" # Process credit card payment elsif @payment_method == \"paypal\" # Process PayPal payment end end end   There is an obvious flaw in the above code: if we want to add a new payment method, such as bank transfer, we need to modify the process_payment method. This violates the Open-Closed Principle (OCP), which states that we should be closed to modification but open to extension.\nTo comply with the OCP, we can use the Strategy pattern to redesign the code. First, we create an abstract PaymentStrategy class that includes a process_payment method:\n上述代碼有一個明顯的缺點：如果我們想要添加一種新的付款方式，例如銀行轉賬，我們需要修改 process_payment 方法。這違反了 OCP 的原則，因為我們應該對修改關閉，對擴展開放。\n為了符合 OCP 的原則，我們可以使用策略模式來重新設計上述代碼。首先，我們創建一個抽象的 PaymentStrategy 類別，該類別包含一個 process_payment 方法：\n1 2 3 4 5  class PaymentStrategy def process_payment(amount) raise NotImplementedError, \"Subclass must implement this method\" end end   Then, we create concrete payment strategies, such as CreditCardPayment and PayPalPayment classes, which inherit from PaymentStrategy and implement the process_payment method:\n然後，我們創建具體的付款策略，例如 CreditCardPayment 和 PayPalPayment 類別，這些類別繼承自 PaymentStrategy 並實現 process_payment 方法：\n1 2 3 4 5 6 7 8 9 10 11  class CreditCardPayment \u003c PaymentStrategy def process_payment(amount) # Process credit card payment end end class PayPalPayment \u003c PaymentStrategy def process_payment(amount) # Process PayPal payment end end   Finally, we modify the Payment class to accept a PaymentStrategy object as the payment method:\n最後，我們修改 Payment 類別，使其接受一個 PaymentStrategy 對象作為付款方式：\n1 2 3 4 5 6 7 8 9 10  class Payment def initialize(amount, payment_strategy) @amount = amount @payment_strategy = payment_strategy end def process_payment @payment_strategy.process_payment(@amount) end end   Now, if we want to add a new payment method, such as bank transfer, we only need to create a BankTransferPayment class, inherit from PaymentStrategy, and implement the process_payment method. Then, we can use the new payment method like this:\n現在，如果我們想要添加一種新的付款方式，例如銀行轉賬，我們只需要創建一個 BankTransferPayment 類別，繼承自 PaymentStrategy 並實現 process_payment 方法。然後，我們可以像這樣使用新的付款方式：\n1 2  payment = Payment.new(amount, BankTransferPayment.new) payment.process_payment   This implementation complies with the OCP, because we can add new payment methods without modifying the existing code.\n這種實現方式符合 OCP 的原則，因為我們可以添加新的付款方式而不需要修改現有的代碼。\nExample 3 (LSP) The Liskov Substitution Principle (LSP) is a fundamental principle in object-oriented design. It states that a subclass must be able to replace its parent class without affecting the correctness of the program.\n里氏替換原則 (Liskov Substitution Principle, LSP) 是面向對象設計中的一個基本原則，它指出子類別必須能夠替換其父類別，而不會對程式的正確性造成任何影響。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 不符合 LSP 的範例 class Animal def speak puts \"Animal is speaking.\" end end class Dog \u003c Animal def speak puts \"Dog is barking.\" end end def do_something(animal) animal.speak end dog = Dog.new do_something(dog) # 輸出：Dog is barking.   In this example, we have defined an Animal parent class and a Dog subclass. The Animal class defines a speak method, while the Dog subclass overrides the speak method of the parent class and writes its own specific behavior.\nIn the do_something method, we pass in a Dog object and then invoke its speak method. Since Dog overrides the speak method in Animal, when the speak method is called, the output is the specific behavior of Dog, not Animal. This violates the requirement of LSP: the parent class and the subclass cannot be used interchangeably because their behaviors are different.\nHere is a modification that satisfies LSP:\n在這個例子中，我們定義了一個 Animal 父類別和一個 Dog 子類別。Animal 父類別定義了一個 speak 方法，而 Dog 子類別覆寫了父類別中的 speak 方法，改寫成了自己特定的行為。\n在 do_something 方法中，我們傳入一個 Dog 物件，然後調用它的 speak 方法。由於 Dog 覆寫了 Animal 中的 speak 方法，因此在調用 speak 方法時，輸出的是 Dog 的特定行為，而不是 Animal 的行為。這樣就違反了 LSP 的要求：父類別和子類別不可以互相替換使用，因為它們的行為不同。\n以下是符合 LSP 的修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Animal def speak puts \"Animal is speaking.\" end end class Dog \u003c Animal # Dog 類別繼承自 Animal 類別，並沒有修改或覆寫 Animal 中的 speak 方法 end def do_something(animal) animal.speak end dog = Dog.new do_something(dog) # 輸出：Animal is speaking.   在這個例子中，我們定義了一個 Animal 父類別和一個 Dog 子類別。Animal 父類別定義了一個 speak 方法，而 Dog 子類別沒有修改或覆寫 Animal 中的 speak 方法，直接繼承了父類別中的方法。\n在 do_something 方法中，我們傳入一個 Animal 物件（這裡是 Dog 物件），然後調用它的 speak 方法。由於 Dog 繼承自 Animal，因此它也擁有一個 speak 方法，可以替代 Animal 物件的位置。這樣就符合了 LSP 的要求：父類別和子類別可以互相替換使用，而不會對系統的正確性造成影響。\nExample 4 (ISP) The Interface Segregation Principle (ISP) states that a large interface should be split into smaller ones, and each class should only implement the interfaces that it needs. This reduces unnecessary dependencies and improves code readability, maintainability, and extensibility.\nIn Ruby, we can implement the ISP using modules. Here’s a simple example:\n介面隔離原則（Interface Segregation Principle, ISP）是指應該將一個大型的介面拆分成多個小的介面，並且每個類別只實現它需要的介面。這樣可以減少不必要的依賴關係，從而提高代碼的可讀性、可維護性和可擴展性。\n在 Ruby 中，我們可以通過模塊（Module）來實現介面隔離原則。以下是一個簡單的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  module Swimable def swim puts \"#{self.class}is swimming\" end end module Flyable def fly puts \"#{self.class}is flying\" end end class Bird include Flyable def eat puts \"#{self.class}is eating\" end end class Duck \u003c Bird include Swimable def quack puts \"Quack!\" end end duck1 = Duck.new duck1.quack # Quack! duck1.eat # Duck is eating duck1.fly # Duck is flying   In the example above, we defined two modules: Swimable and Flyable, which define the swim and fly methods, respectively. Then, we defined a Bird class and included the Flyable module, because birds can fly. We also defined a Duck class that inherits from Bird and includes the Swimable module, because ducks can swim.\nThe benefit of this design is that each class only implements the interfaces that it needs, reducing dependencies between classes. For example, if we need a bird that cannot fly, we can simply derive a new class from Bird without modifying the existing code.\n在上面的例子中，我們定義了兩個模塊：Swimable 和 Flyable，它們分別定義了 swim 和 fly 方法。然後我們定義了一個 Bird 類別，並包含了 Flyable 模塊，因為鳥類能夠飛行。接著，我們定義了一個 Duck 類別，它繼承自 Bird 類別，並包含了 Swimable 模塊，因為鴨子能夠游泳。\n這樣設計的好處是，每個類別只實現了自己需要的介面，從而減少了類別之間的依賴關係。例如，如果我們需要一個不能飛行的鳥類，我們只需要從 Bird 類別派生一個新類別，而不需要修改原有的代碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class NonFlyingBird \u003c Bird def fly puts \"#{self.class}cannot fly\" end end class Penguin \u003c NonFlyingBird include Swimable def waddle puts \"Waddle waddle\" end end penguin1 = Penguin.new penguin1.waddle # waddle waddle penguin1.eat # Penguin is eating penguin1.fly # Penguin cannot fly   In this code, we define a new class called NonFlyingBird that inherits from the Bird class. However, we override the fly method to output a message saying that the bird cannot fly.\nWe can now use this new class to define non-flying birds without modifying the original Bird class or the Flyable module.\n在上面的代碼中，我們定義了一個 NonFlyingBird 類別，它繼承自 Bird 類別，但是重寫了 fly 方法，讓它輸出一個不能飛行的信息。然後，我們定義了一個 Penguin 類別，它繼承自 NonFlyingBird 類別，並包含了 Swimable 模塊，因為企鵝可以游泳。Penguin 類別也定義了自己的方法 waddle。\n現在，如果我們需要一個不能飛行的鳥類，我們只需要使用 NonFlyingBird 類別即可，不需要修改原有的 Bird 類別或 Flyable 模塊。\nExample 5 (DIP) The Dependency Inversion Principle (DIP) is one of the SOLID design principles. It states that high-level modules should not depend on low-level modules, but both should depend on abstractions. By relying on abstractions, the system’s coupling is reduced, and it becomes easier to perform unit testing and module replacement.\nHere’s an example of Ruby code that violates the Dependency Inversion Principle:\n依賴反轉原則（Dependency Inversion Principle, DIP）是 SOLID 設計原則中的一個，主要原則是指高層模組不應該依賴於低層模組，而兩者都應該依賴於抽象介面，由抽象介面來統一管理。這樣可以達到降低系統耦合度的目的，並且方便進行單元測試和模組替換。\n以下是一個不符合依賴反轉原則的 Ruby 範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Car def initialize @engine = Engine.new end def start @engine.start end end class Engine def start puts \"Engine started\" end end   In this example, the Car class directly depends on the Engine class, which is a low-level module. This violates the Dependency Inversion Principle.\nIn Ruby, implementing the Dependency Inversion Principle can be achieved through Duck Typing since Ruby is a dynamically typed language. If a class implements a method, it can be considered as implementing an interface.\nTherefore, in Ruby, it is usually unnecessary to create an interface. Instead, we only need to ensure that the lower-level module implements the methods that the higher-level module needs. We can use modules or Ruby’s multiple inheritance feature to make the lower-level module implement the required methods of the higher-level module.\nHere’s an example of using a module to implement the Dependency Inversion Principle in Ruby: 在這個例子中，Car 類別直接依賴於 Engine 類別，而 Engine 類別也是低層模組，這樣就違反了依賴反轉原則。\n在 Ruby 中，實作依賴反轉原則可以使用 Duck Typing，因為 Ruby 是一個動態類型的語言。如果一個類別實現了一個方法，它就可以被視為實現了一個接口。\n因此，在 Ruby 中，通常不需要建立一個介面，只要確定低層模組實現了高層模組需要使用的方法即可。我們可以使用模組或者 Ruby 的多重繼承功能，讓低層模組實現高層模組需要使用的方法。\n以下是一個使用模組實現依賴反轉原則的 Ruby 範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  module EngineInterface def start raise NotImplementedError, \"#{self.class}##{__method__}must be implemented\" end end class Car def initialize(engine) @engine = engine end def start @engine.start end end class Engine include EngineInterface def start puts \"Engine started\" end end engine = Engine.new car = Car.new(engine) car.start   In this example, we define a module, EngineInterface, which Engine class implements so that it can implement the methods that Car needs to use. The Car class accepts an argument engine, which can be any class that implements the EngineInterface module. This allows the Car class to depend on an abstract interface rather than the lower-level Engine class itself.\nIn Ruby, as long as a specific method exists in the object being called, even if the method is not explicitly defined as an interface, Ruby can still find and call that method.\nHowever, this approach is not recommended. If you want to modify the name or parameters of the start method in the Engine class, or if you want other classes to implement the EngineInterface module, you may need to modify the Car class. If you create an explicit interface, such modifications can be simpler because you only need to make the Engine class implement the new interface, rather than modifying the Car class.\nIn summary, even though Ruby does not have explicit interfaces like some other languages, using abstract interfaces to implement the Dependency Inversion Principle is still a good practice because it can make the system more flexible and maintainable.\n在這個例子中，我們定義了一個模組 EngineInterface，讓 Engine 類別實現這個模組，這樣 Engine 就能夠實現 Car 需要使用的方法。Car 類別接收一個引數 engine，這個引數可以是任何實現了 EngineInterface 模組的類別。這樣就讓 Car 類別依賴於一個抽象介面，而不是低層模組 Engine 類別本身。\n在 Ruby 中，對於某個特定的方法，只要該方法存在於被呼叫的物件中，即使該方法沒有被明確地定義為介面，Ruby 仍然可以找到該方法並呼叫它。\n然而，這種做法並不推薦。如果您想要在 Engine 類別中修改 start 方法的名稱或者參數，或者您想要讓其他類別實現 EngineInterface 模組，您可能需要對 Car 類別進行修改。如果您建立了一個明確的介面，這樣的修改就可以更加簡單，因為您只需要讓 Engine 類別實現新的介面即可，而不需要對 Car 類別進行修改。\n總之，即使在 Ruby 中沒有像其他語言中一樣明確的介面，使用抽象介面來實現依賴反轉原則仍然是一種好的做法，因為這樣可以讓系統更具彈性和可維護性。\n","description":"","tags":null,"title":"SOLID Example","uri":"/posts/solid_example/"},{"categories":null,"content":"What is MVC MVC stands for Model-View-Controller, which is a software design pattern used in developing applications, particularly in web application development.\nIn the MVC pattern, the application is divided into three main parts:\nModel: represents the core business logic of the application, such as databases, files, APIs, etc. The Model is typically used for accessing, modifying, and querying data.\nView: represents the user interface of the application, responsible for presenting data to the user. The View typically only concerns itself with data presentation and does not involve business logic.\nController: represents the control logic of the application, responsible for receiving user input and calling the Model and View accordingly. The Controller typically includes the application’s logic processing and routing.\nUsing the MVC pattern can help keep different parts of an application separate, reduce coupling, and improve maintainability and scalability.\nMVC 是什麼 MVC 代表 Model-View-Controller，是一種軟體設計模式，用於開發應用程式，特別是在Web應用程式開發中非常常見。\n在MVC模式中，應用程式被分為三個主要部分：\nModel（模型）：表示應用程式的核心業務邏輯，例如資料庫、文件、API等。Model 通常用於存取、修改、查詢資料。\nView（視圖）：表示應用程式的使用者介面，負責呈現資料給使用者。View 通常只負責呈現資料，而不涉及業務邏輯。\nController（控制器）：表示應用程式的控制邏輯，負責接收使用者的輸入，並相應地調用 Model 和 View。Controller 通常包含了應用程式的邏輯處理和路由。\n使用MVC模式可以讓應用程式的不同部分之間保持獨立，減少耦合，提高應用程式的可維護性和擴展性。\n","description":"","tags":null,"title":"MVC","uri":"/posts/mvc/"},{"categories":null,"content":"What is SOLID SOLID is an acronym for a set of five design principles for writing maintainable and scalable software. These principles were introduced by Robert C. Martin (also known as “Uncle Bob”) and have become widely accepted as best practices in software development.\nHere’s a brief overview of each principle:\nSingle Responsibility Principle (SRP): A class should have only one reason to change. This means that a class should have only one responsibility or job. This principle helps in reducing complexity and making the code easier to maintain.\nOpen/Closed Principle (OCP): Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means that you should be able to add new functionality without changing the existing code. This principle helps in making the code more modular and flexible.\nLiskov Substitution Principle (LSP): Subtypes must be substitutable for their base types. This means that any object of a class should be able to be replaced with an object of its subclass without affecting the correctness of the program. This principle helps in ensuring the correct behavior of the code when using polymorphism.\nInterface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use. This means that a class should not be forced to implement methods it doesn’t need. This principle helps in making the code more modular and preventing unnecessary dependencies.\nDependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. This means that the high-level modules should be independent of the low-level modules and should instead depend on abstractions. This principle helps in making the code more flexible and easier to maintain.\nTogether, these five principles form SOLID, a set of guidelines that can help you write more maintainable and scalable software.\nSOLID 是什麼 SOLID原則是一組關於撰寫可維護性和可擴展性軟體的五個設計原則。這些原則由Robert C. Martin（也稱為\"Uncle Bob\"）所提出，已成為軟體開發中廣泛接受的最佳實踐。\n以下是每個原則的簡要概述：\n單一職責原則（SRP）：一個類別應該只有一個變更的原因。這意味著一個類別只應該有一個職責或工作。這個原則有助於減少複雜性，使程式碼更容易維護。\n開放/封閉原則（OCP）：軟體實體（類別、模組、函式等）應該對擴展開放，但對修改封閉。這意味著您應該能夠添加新功能而不更改現有的程式碼。這個原則有助於使程式碼更模組化和靈活。\n里氏替換原則（LSP）：子類別必須能夠替換其基類別。這意味著一個類別的任何物件都應該能夠被其子類別的物件替換，而不會影響程式的正確性。這個原則有助於確保使用多型時程式碼的正確行為。\n介面隔離原則（ISP）：客戶端不應被迫依賴它們不使用的介面。這意味著一個類別不應被迫實現它不需要的方法。這個原則有助於使程式碼更模組化並防止不必要的相依性。\n依賴反轉原則（DIP）：高層模組不應依賴於低層模組。兩者都應該依賴於抽象。抽象不應該依賴於細節。細節應該依賴於抽象。這意味著高層模組應該獨立於低層模組，而應該依賴於抽象。這個原則有助於使代碼更具靈活性和易於維護。\n這五個原則組成了SOLID，是一套指南，可幫助您撰寫更具可維護性和可擴展性的軟體。\n 單一職責原則 (Single Responsibility Principle, SRP)  1 2 3 4 5 6 7 8 9 10  class User def initialize(name, email) @name = name @email = email end def save # save user to database end end   上面的 User 類別只負責儲存使用者資料，而不負責其他的功能。\n開放封閉原則 (Open-Closed Principle, OCP)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Payment def process raise NotImplementedError, \"Subclass must implement abstract method\" end end class CreditCardPayment \u003c Payment def process # process credit card payment end end class PayPalPayment \u003c Payment def process # process PayPal payment end end   上面的 Payment 類別是一個抽象類別，其中包含一個抽象方法 process，並且 CreditCardPayment 和 PayPalPayment 兩個子類別都繼承了 Payment 類別，並實作了 process 方法。這樣可以在不修改 Payment 類別的情況下，新增其他的付款方式。\n里氏替換原則 (Liskov Substitution Principle, LSP)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Animal def make_sound raise NotImplementedError, \"Subclass must implement abstract method\" end end class Dog \u003c Animal def make_sound \"Woof\" end end class Cat \u003c Animal def make_sound \"Meow\" end end   上面的 Animal 類別是一個抽象類別，其中包含一個抽象方法 make_sound，並且 Dog 和 Cat 兩個子類別都繼承了 Animal 類別，並實作了 make_sound 方法。由於 Dog 和 Cat 都能替代 Animal，因此可以在使用 Animal 的地方使用 Dog 或 Cat。\n介面隔離原則 (Interface Segregation Principle, ISP)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Order def initialize(payment_method) @payment_method = payment_method end def process_payment @payment_method.process_payment end end class CreditCardPayment def process_payment # process credit card payment end end class PayPalPayment def process_payment # process PayPal payment end end   上面的 Order 類別需要依賴於一個付款方式，並且透過該付款方式來進行付款。因此，CreditCardPayment 和 PayPalPayment 兩個類別必須實作一個名為 process_payment 的方法，以便讓 Order 類別使用。\n依賴反轉原則 (Dependency Inversion Principle, DIP)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Order def initialize(payment_method) @payment_method = payment_method end def process_payment @payment_method.process_payment end end class PaymentMethod def process_payment raise NotImplementedError, \"Subclass must implement abstract method\" end end class CreditCardPayment \u003c PaymentMethod def process_payment # process credit card payment end end class PayPalPayment \u003c PaymentMethod def process_payment # process PayPal payment end end   上面的 Order 類別需要依賴於一個付款方式，並且透過該付款方式來進行付款。然而，Order 類別不應該依賴於具體的付款方式，而應該依賴於一個抽象的付款方式，因為具體的付款方式可能會變更，而抽象的付款方式則是不會變更的。\n因此，我們新增了一個 PaymentMethod 類別，其中包含一個抽象的方法 process_payment，並且 CreditCardPayment 和 PayPalPayment 兩個子類別都繼承了 PaymentMethod 類別，並實作了 process_payment 方法。這樣，Order 類別就可以依賴於 PaymentMethod 類別，而不是依賴於具體的付款方式。如果需要新增其他的付款方式，只需要繼承 PaymentMethod 類別並實作 process_payment 方法即可。這樣，就符合依賴反轉原則。\nMore examples \n","description":"","tags":null,"title":"SOLID","uri":"/posts/solid/"},{"categories":null,"content":"What is Bash Bash, short for “Bourne-Again SHell”, is a Unix shell and command language that is widely used on Unix and Linux operating systems. It was written by Brian Fox for the GNU Project as a free software replacement for the original Bourne shell (sh), and has since become the default shell on most Linux distributions as well as on macOS.\nAs a command language, Bash allows users to interact with a Unix-based operating system through a command-line interface. Users can enter commands to launch applications, manipulate files and directories, run scripts, and perform other system-related tasks. Bash also provides features such as command history, tab completion, and input and output redirection, which can help users work more efficiently.\nBash is also a scripting language, which means that users can write Bash scripts to automate repetitive tasks or perform more complex operations. Bash scripts can be used for a variety of purposes, such as system administration, data processing, and web development, among others.\nOverall, Bash is a powerful and versatile tool for working with Unix-based operating systems, and is widely used by developers, system administrators, and power users alike.\nWhat’s the different with Zsh Zsh, short for “Z Shell”, is another Unix shell and command language, and is also widely used on Unix and Linux operating systems. Zsh was developed as an extended version of the Bourne shell (sh) and the Korn shell (ksh), and offers many features and enhancements that are not available in Bash.\nOne major difference between Bash and Zsh is that Zsh has better tab completion and correction capabilities. Zsh provides more advanced tab completion, which allows for more flexible and efficient command-line usage. Zsh also has a feature called “correction,” which automatically corrects common spelling mistakes and other errors in commands.\nAnother difference is that Zsh has a built-in module system that allows for easy customization and extension of the shell. Users can add or remove features and functionalities by loading or unloading modules, making it easier to tailor the shell to their specific needs.\nFinally, Zsh has a more modern and user-friendly configuration system, which makes it easier to customize and configure the shell to the user’s preferences.\nOverall, while Bash and Zsh share many similarities, Zsh provides more advanced features and customization options, making it a popular choice among power users and developers who require a high level of flexibility and control over their shell environment.\nWhat’s the different with JavaScript Bash and JavaScript are two very different programming languages that serve different purposes.\nBash is primarily a scripting language used for automating tasks and running system commands on Unix and Linux operating systems. It is typically used in a command-line interface and has a syntax optimized for executing commands and manipulating files and directories. Bash is often used for tasks such as system administration, automation, and data processing.\nJavaScript, on the other hand, is a high-level programming language that is used primarily for web development. It is executed within web browsers and is used to add interactivity and dynamic behavior to web pages. JavaScript is also used on the server side with Node.js to build full-stack web applications, as well as for developing mobile and desktop applications.\nWhile both Bash and JavaScript are used for programming, their syntax, use cases, and features are very different. Bash is focused on running system commands and automating tasks, while JavaScript is focused on building interactive and dynamic web applications.\nFile/directory permissions In Linux/Unix systems, every file and directory has a set of permissions that control access to that file or directory. Permissions are determined by three categories: owner, group, and others.\nEach category can have three types of permissions: read (r), write (w), and execute (x). These permissions have the following meanings:\nRead permission (r): Can read and view the contents of the file or directory. Write permission (w): Can modify the contents of the file or directory, including adding, deleting, and renaming. Execute permission (x): For files, can run executable files; for directories, can enter the directory. Permissions can be represented using numbers or letters. When using letters to represent permissions, r represents read permission, w represents write permission, and x represents execute permission. When using numbers to represent permissions, each permission has a numeric value, with r as 4, w as 2, and x as 1, so rwx is 7 (4+2+1).\nFor example, a file with permission -rw-r–r– means the owner has read and write permissions while the group and others only have read permission.\nBash commands  ls -l filename: display detailed information about a file or directory. The “-l” option stands for “long” and displays additional information, such as the file or directory’s permissions, owner, group, size, creation date, and modification date. cd: change the current directory pwd: display the full path of the current working directory mkdir: create a new directory rm: remove files or directories cp: copy files or directories mv: move or rename files or directories cat: view the contents of a file less: view the contents of a file one page at a time grep: search for a specified string in a file find: search for a specified file or directory in the file system chmod: change the permissions of a file or directory e.g. chmod +x filename chown: change the owner of a file or directory  Build up Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/bash #3hours=10800 s reminder_interval=10 next_reminder=$(($(date +%s) + $reminder_interval)) while true; do current_time=$(date +%s) if [ $current_time -ge $next_reminder ]; then echo \"it's time to drink water\" next_reminder=$((current_time + $reminder_interval)) fi sleep 5 done     #!/bin/bash: This is a shebang line that specifies which interpreter should be used to execute the script. In this case, it specifies that the Bash shell should be used.\n  #3hours=10800 s: This is a comment line that provides a brief explanation of what the script does. It notes that 3 hours equals 10,800 seconds.\n  reminder_interval=10: This line sets a variable called reminder_interval to 10, which represents the number of seconds between reminders to drink water.\n  next_reminder=$(($(date +%s) + $reminder_interval)): This line calculates the time of the next reminder to drink water by getting the current time in seconds since the Unix epoch (date +%s) and adding the reminder interval to it. The result is stored in a variable called next_reminder.\n  while true; do: This starts an infinite loop that will continue until the script is interrupted or killed.\n  current_time=$(date +%s): This line gets the current time in seconds since the Unix epoch and stores it in a variable called current_time.\n  if [ $current_time -ge $next_reminder ]; then: This line checks whether the current time is greater than or equal to the next reminder time. If it is, the script will print a message reminding the user to drink water.\n  echo \"it's time to drink water\": This line prints a reminder message to the console.\n  next_reminder=$((current_time + $reminder_interval)): This line updates the next_reminder variable to be the current time plus the reminder interval.\n  fi: This line closes the if statement.\n  sleep 5: This line pauses the script for 5 seconds before starting the loop again. This delay is used to prevent the script from consuming too many system resources.\n   A shell is a command-line interface (CLI) that provides a way for users to interact with an operating system. In Unix and Unix-like systems, such as macOS and Linux, the shell is an interface through which users can enter commands to interact with the operating system. Common shells in Unix systems include Bash, Zsh, Ksh, Tcsh, and others. In macOS, the default shell is Zsh.\n  Bash scripting cheatsheet\n Bash 是什麼 Bash（Bourne-Again SHell）是一種在Linux和其他Unix操作系統上常用的命令行解釋器，它是由Brian Fox和Chet Ramey於1987年開發的。Bash是一種文本界面的操作環境，可以通過在終端窗口中輸入命令來執行各種系統操作，例如檔案管理、系統配置、程序啟動等。Bash支持各種內置命令和腳本語言，這些功能可以用於自動化和編寫各種系統管理任務。\nBash是Linux系統中最常見的shell之一，也是許多Unix系統預設的shell。Bash具有豐富的功能，如命令自動完成、歷史命令查詢、腳本編寫等，使得用戶可以更加高效地使用Linux和其他Unix系統。\n與 Zsh 的差異 Zsh（Z shell）是一種強大的命令行解釋器，也是Linux和Unix系統中的一種shell。Zsh與Bash非常相似，兩者都提供了一個強大的命令行界面，可以用於檔案管理、腳本編寫和系統管理等任務。但是，Zsh相對於Bash在以下幾個方面有一些不同之處：\n自動補全：Zsh提供更強大的自動補全功能，支持多個輸入源，如歷史命令、檔案、目錄等。\n設定管理：Zsh提供更簡單的設定管理方式，包括類似於Oh My Zsh的外掛程式，可以幫助用戶快速定制shell界面和功能。\n選項設定：Zsh提供了更多的選項設定，例如更好的警告和錯誤信息、更豐富的Shell Parameter Expansion等。\n終端顏色：Zsh內建支援更豐富的終端顏色和風格選項。\n總的來說，Zsh和Bash都是強大的命令行解釋器，兩者有很多共同點，但是Zsh在一些方面提供了更強大和便利的功能。當然，哪種shell更適合您取決於您個人的偏好和需求。\n跟 javascript 有什麼不同 Bash和JavaScript都是程式語言，但它們有著不同的用途和設計目標，因此有以下幾個不同之處：\n用途不同：Bash主要用於在Unix和Linux系統上進行系統管理和自動化任務，而JavaScript主要用於網頁前端和後端開發。\n語言特性不同：Bash是一種腳本語言，它具有許多與命令行相關的特性，例如命令行解釋、管道和重定向等。而JavaScript是一種通用的語言，具有面向對象、函數式和事件驅動等特性。\n運行環境不同：Bash在Unix和Linux系統上運行，而JavaScript可以在網頁瀏覽器、Node.js和其他JavaScript運行環境中運行。\n語言生態系統不同：Bash的生態系統主要集中在Unix和Linux系統中，而JavaScript擁有廣泛的生態系統，包括許多框架、函式庫和工具。\n總的來說，Bash和JavaScript都是程式語言，但是它們的設計目標和用途不同，因此擁有不同的語言特性和生態系統。\n文件權限 在 Linux/Unix 系統中，每個文件和目錄都有一組權限，控制對該文件或目錄的訪問。權限是由三個類別決定的：所有者、群組和其他人。\n每個類別可以有三種權限：讀取（r）、寫入（w）和執行（x）。這些權限的意義如下：\n讀取權限（r）：可以讀取和查看文件或目錄的內容。 寫入權限（w）：可以修改文件或目錄的內容，包括添加、刪除和重命名。 執行權限（x）：對於文件，可以運行可執行文件；對於目錄，可以進入目錄。 權限可以用數字或字母表示。使用字母表示權限時，r 表示讀取權限，w 表示寫入權限，x 表示執行權限。使用數字表示權限時，每種權限都有一個數字值，r 為 4，w 為 2，x 為 1，因此 rwx 為 7（4+2+1）。\n例如，權限為 -rw-r–r– 的文件表示所有者具有讀寫權限，而群組和其他人僅具有讀取權限。\nBash 命令 echo $SHELL確認目前 macOS 系統使用的 shell chsh -s /bin/bash更改當前的 shell為 Bash shell\n ls -l 檔案名: 顯示文件和目錄詳細信息的命令，其中 “-l” 參數表示 “long”，可以顯示文件或目錄的詳細屬性信息。這些詳細信息包括文件/目錄的權限、所有者、所屬組、大小、創建日期、修改日期等。 cd：改變當前目錄。 pwd：顯示當前工作目錄的完整路徑。 mkdir：創建一個新目錄。 rm：刪除文件或目錄。 cp：複製文件或目錄。 mv：移動或重命名文件或目錄。 cat：查看文件的內容。 less：逐頁查看文件內容。 grep：在文件中搜索指定字串。 find：在文件系統中搜索指定文件或目錄。 chmod：更改文件或目錄的權限。 e.g. chmod +x 檔案名;chmod g+x 檔案名，權限類別可以是 u（所有者）、g（群組）或 o（其他人）。使用 + 來添加權限，- 來移除權限，或 = 來設置權限。x 表示執行權限。 chown：更改文件或目錄的所有者。  範例  新增並編輯腳本 nano stay_hyderated.sh 執行 ./stay_hyderated.sh 每隔15秒會顯示it's time to drink water   stay_hyderated.sh腳本內容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/bash #3hours=10800 s reminder_interval=10 next_reminder=$(($(date +%s) + $reminder_interval)) while true; do current_time=$(date +%s) if [ $current_time -ge $next_reminder ]; then echo \"it's time to drink water\" next_reminder=$((current_time + $reminder_interval)) fi sleep 5 done   這個範例是一個bash腳本，用來提醒你每隔一段時間就要喝水。腳本首先定義了一個變量reminder_interval，表示提醒的間隔時間，這裡設置為10秒。\n接下來，腳本進入一個無限循環中，每次循環都會檢查當前時間是否已經超過了下一個提醒時間。如果已經到達了提醒時間，腳本會輸出一條消息，提示你喝水 it's time to drink water ，然後更新下一個提醒時間為當前時間加上提醒間隔時間。\n循環的每次迭代之間，腳本會暫停5秒，以減少系統資源的使用。\n等於每個循環會間隔10秒，然後腳本會等待5秒再進入下一個循環，這樣每個循環總共會耗時大約15秒左右（10秒的提醒間隔加上5秒的暫停時間）。\n每行說明如下\n  #!/bin/bash: Shebang是一種特殊的註釋語法，用於指定腳本應使用哪個解譯器來執行。它通常是腳本文件的第一行，並以#!開頭。本行指定了腳本的解釋器，即在執行腳本時使用Bash作為解釋器。\n  #3hours=10800 s: 第一行指定了腳本的解釋器，即在執行腳本時使用Bash作為解釋器。\n  reminder_interval=10: 這一行設置reminder_interval變量的值為10，即提醒的間隔時間為10秒。\n  next_reminder=$(($(date +%s) + $reminder_interval)): 計算下一個提醒時間，它使用$(...)來運行一個子命令。  $(date +%s) 用於獲取當前時間的UNIX時間戳（以秒為單位），然後加上reminder_interval的值來計算下一個提醒時間。\n  while true; do: 這是一個無限循環的開始。它使用while true來表示進入一個無限循環中，因為 true 總是返回成功。\n  current_time=$(date +%s): 獲取當前時間的UNIX時間戳，並將其賦值給current_time變量。\n  if [ $current_time -ge $next_reminder ]; then: 一個if語句，用於檢查是否已經到達下一個提醒時間。-ge 表示大於或等於，如果current_time大於或等於next_reminder，那麼就執行then後面的語句。\n  echo \"it's time to drink water\": 如果到達了提醒時間，則輸出一條消息，提示你喝水。\n  next_reminder=$((current_time + $reminder_interval)): 這一行更新next_reminder的值，以計算下一個提醒時間。它使用$((...))來執行一個算術運算，計算當前時間加上提醒間隔時間的值。\n  fi: 這是if語句的結束標記。\n  sleep 5: 這一行使腳本暫停5秒，以減少系統資源的使用。每次循環之間暫停一段時間可以使腳本不會一直忙碌並浪費資源。\n  done: 這是無限循環的結束。\n   Shell 是一種命令行界面（Command Line Interface, CLI），是一個人與操作系統之間進行互動的方式。在 Unix 和類 Unix 系統（如 macOS 和 Linux）中，Shell 是一個介面，用戶可以通過命令行輸入命令，從而與操作系統進行互動。\n  Bash scripting cheatsheet\n ","description":"","tags":null,"title":"Bash and Zsh","uri":"/posts/bash_and_zsh/"},{"categories":null,"content":"Include vs Extend In Ruby, include and extend are both methods used to add module methods to a class.\nThe include method adds the module’s methods to the instance methods of a class, meaning the methods from the included module can be called by instances of the class.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11 12  module HiModule def hi_method puts \"Hi, this is my method!\" end end class HiClass include HiModule end obj = HiClass.new obj.hi_method # =\u003e Hi, this is my method!   In the above code, the MyClass class includes a MyModule module, and the methods from MyModule module can be called by instance methods of MyClass class (i.e., obj.my_method).\nOn the other hand, the extend method adds the module’s methods to the class methods of a class, meaning the methods from the extended module can be called directly by the class itself, without instantiating any objects.\nFor example:\n1 2 3 4 5 6 7 8 9 10 11  module HiModule def hi_method puts \"Hi, this is my method!\" end end class HiClass extend HiModule end HiClass.hi_method # =\u003e Hi, this is my method!   In the above code, the MyClass class extends the MyModule module, and the methods from MyModule module can be called directly by class methods of MyClass class (i.e., MyClass.my_method).\nIn summary, the include method is used to add module methods to a class’s instance methods, while the extend method is used to add module methods to a class’s class methods.\nInclude vs Extend 在Ruby中，include和extend都是用來將模組（module）的方法添加到類（class）中的方法。\ninclude方法可以將模組的方法添加到類的實例方法中，即被添加的模組的方法可以被該類的實例調用。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12  module HiModule def hi_method puts \"Hi, this is my method!\" end end class HiClass include HiModule end obj = HiClass.new obj.hi_method # =\u003e Hi, this is my method!   上述代碼中，MyClass類包含一個MyModule模組，並且MyModule模組中的方法可以被MyClass類的實例方法（即obj.my_method）調用。\nextend方法可以將模組的方法添加到類的類方法中，即被添加的模組的方法可以直接被該類調用，而不需要實例化對象。\n1 2 3 4 5 6 7 8 9 10 11  module HiModule def hi_method puts \"Hi, this is my method!\" end end class HiClass extend HiModule end HiClass.hi_method # =\u003e Hi, this is my method!   上述代碼中，MyClass類擴展了MyModule模組，並且MyModule模組中的方法可以直接被MyClass類的類方法（即MyClass.my_method）調用，而不需要實例化對象。\n簡單來說，include方法用於將模組的方法添加到類的實例方法中，而extend方法用於將模組的方法添加到類的類方法中。\n","description":"","tags":null,"title":"Include vs Extend","uri":"/posts/include_vs_extend/"},{"categories":null,"content":"What is “Excapsulation” Encapsulation is a fundamental concept in object-oriented programming (OOP) that refers to the bundling of data and the methods that act on that data into a single unit called a class.\nEncapsulation enables the programmer to hide the implementation details of the class from the outside world and provide a clean and well-defined interface for accessing and modifying the data.\nBy encapsulating data and methods within a class, we can ensure that the data is accessed and modified only through the methods provided by the class, thereby preventing unauthorized access and manipulation of the data.\nIn other words, encapsulation provides data protection and promotes data integrity by preventing accidental modification of data by other parts of the program.\nExample In addition to attr_reader, attr_writer, and attr_accessor, see example here. Ruby offers other ways to achieve encapsulation.\nOne way is to use the private and protected keywords to restrict method access. For example, we can make some methods private or protected to limit external access:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Person def initialize(name, age) @name = name @age = age end def name @name end def age @age end def age=(new_age) validate_age(new_age) @age = new_age end def greet puts \"Hello, my name is #{@name}and I am #{@age}years old.\" end private def validate_age(age) raise \"Invalid age\" unless age.is_a?(Integer) \u0026\u0026 age \u003e 0 end end   In the example above, we made the validate_age method private to limit external access. We can also make the greet method public to allow external calling.\nAnother way is to use module to create namespaces and encapsulate classes. For example, we can put some related methods into a module and include them in the class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  module Validation def validate_age(age) raise \"Invalid age\" unless age.is_a?(Integer) \u0026\u0026 age \u003e 0 end end class Person include Validation def initialize(name, age) @name = name @age = age end def name @name end def age @age end def age=(new_age) validate_age(new_age) @age = new_age end def greet puts \"Hello, my name is #{@name}and I am #{@age}years old.\" end end   In the example above, we put the validate_age method into the Validation module and include it in the Person class. This way, we can validate the age property of Person objects by calling the validate_age method while keeping the interface of the class concise and clear.\nIn Ruby, there are three common ways to encapsulate code: defining class attributes using attr_reader, attr_writer, and attr_accessor methods, limiting method access using the private and protected keywords, and grouping related methods and creating namespaces using module. These techniques can help us better encapsulate our code, improve its readability, maintainability, and reusability.\nExtended reading include vs extend \n封裝是什麼 封裝是物件導向程式設計(OOP)中的一個基本概念，指將數據和作用於數據的方法打包成一個單元，稱為類別。\n封裝使得程式設計師可以隱藏類別的實現細節，為外部世界提供一個清晰且明確的介面，以便存取和修改數據。\n透過封裝，我們可以確保數據只能透過類別提供的方法進行存取和修改，從而防止未經授權的存取和操作數據。\n換句話說，封裝提供了數據保護，並通過防止程序中其他部分意外修改數據來促進數據完整性。\n範例 除了之前介紹過的 attr_reader、attr_writer 和 attr_accessor 之外 範例在這，Ruby 還有其他方式來實現封裝。\n一種方式是使用 private 和 protected 關鍵字來限制方法的訪問權限。例如，我們可以將某些方法設為私有方法或保護方法，以限制外部的訪問：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Person def initialize(name, age) @name = name @age = age end def name @name end def age @age end def age=(new_age) validate_age(new_age) @age = new_age end def greet puts \"Hello, my name is #{@name}and I am #{@age}years old.\" end private def validate_age(age) raise \"Invalid age\" unless age.is_a?(Integer) \u0026\u0026 age \u003e 0 end end   在上面的例子中，我們將 validate_age 方法設為私有方法，以限制外部的訪問。此外，我們還可以將 greet 方法設為公共方法，以允許外部調用。\n另一種方式是使用 module 來創建命名空間和封裝類。例如，我們可以將一些相關的方法放在一個模組中，並將它們導入到類中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  module Validation def validate_age(age) raise \"Invalid age\" unless age.is_a?(Integer) \u0026\u0026 age \u003e 0 end end class Person include Validation def initialize(name, age) @name = name @age = age end def name @name end def age @age end def age=(new_age) validate_age(new_age) @age = new_age end def greet puts \"Hello, my name is #{@name}and I am #{@age}years old.\" end end   在上面的例子中，我們將 validate_age 方法放在 Validation 模組中，並將其包含到 Person 類中。這樣，我們可以通過調用 validate_age 方法來驗證 Person 對象的年齡屬性，同時保持類的接口簡潔和清晰。\n所以在Ruby中，有三種常見的封裝方式：使用attr_reader、attr_writer、attr_accessor等方法定義類的屬性、使用private和protected關鍵字來限制方法的訪問權限，以及使用module來創建命名空間和將相關的方法分組。這些技巧可以幫助我們更好地封裝代碼，提高代碼的可讀性、可維護性和可重用性。\n延伸 include vs extend \n","description":"","tags":null,"title":"Excapsulation","uri":"/posts/excapsulation/"},{"categories":null,"content":"What is “Inheritance” Inheritance is a concept in object-oriented programming where a class (known as a subclass or derived class) can inherit properties and methods from another class (known as a superclass or base class). The subclass can use the properties and methods of the superclass, and can also add new properties and methods as needed.\nInheritance allows for code reuse and extensibility, as the subclass can reuse the code from the superclass without having to rewrite it. Additionally, the subclass can override methods from the superclass, meaning it can provide a new implementation of a method with different behavior.\nIn an inheritance relationship, public properties and methods of the superclass are inherited by the subclass, but private properties and methods are not. The subclass can also call methods from the superclass using the super keyword.\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Animal def initialize(name, age) @name = name @age = age end def say_hello puts \"Hello, my name is #{@name}.\" end end class Dog \u003c Animal def bark puts \"Woof!\" end end my_dog = Dog.new(\"Max\", 3) my_dog.say_hello # Output: \"Hello, my name is Max.\" my_dog.bark # Output: \"Woof!\"   In this example, Animal is a parent class that has an initialize method and a say_hello method. Dog is a subclass that inherits from Animal using \u003c Animal, so it inherits all of Animal’s properties and methods. A new method bark is added in Dog, and Dog can also use Animal’s method say_hello. Through this example, we can see how inheritance works in Ruby.\nsuper In Ruby, “super” is a keyword used to call a method with the same name as the current method in the parent class. Using “super” in a subclass allows the subclass to inherit relevant behavior from the parent class. When a subclass needs to extend certain methods in the parent class, it can define a method with the same name in the subclass and use the “super” keyword to call the method in the parent class, thus inheriting and extending the parent class’s behavior without duplicating code.\nExample with key word super 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class Vehicle def initialize(make, model) @make = make @model = model end def start_engine puts \"#{@make}#{@model}Starting engine...\" end end class Car \u003c Vehicle def initialize(make, model, color) super(make, model) @color = color end def drive puts \"Driving #{@color}car...\" end end class Motorcycle \u003c Vehicle def initialize(make, model, style) super(make, model) @style = style end def ride puts \"Riding #{@style}motorcycle...\" end end my_car = Car.new(\"Toyota\", \"Camry\", \"red\") my_car.start_engine # Toyota Camry Starting engine... my_car.drive # Driving red car... my_motorcycle = Motorcycle.new(\"Harley Davidson\", \"Sportster\", \"cruiser\") my_motorcycle.start_engine # Harley Davidson Sportster Starting engine... my_motorcycle.ride # Riding cruiser motorcycle...   In this example, we have the Vehicle class which include an initialize method that takes two parameters make and model. We then create two subclasses, Car and Motorcycle, which inherit from Vehicle and also define their own initialize methods.\nIn the Car and Motorcycle classes, we use the super keyword to call the initialize method of the parent Vehicle class and pass in the required parameters make and model. We then define our own instance variables @color and @style, respectively.\nWe create instances of each subclass and call their respective methods. This time, when we create instances of Car and Motorcycle, we need to pass in the additional parameter required by their initialize methods. When we call the start_engine method on these objects, it is inherited from the parent class Vehicle. This demonstrates the use of both inheritance and the super keyword in Ruby.\n繼承是什麼 繼承(Inheritance) 是物件導向程式設計中的一個概念，指的是一個類別（稱為子類別或衍生類別）可以繼承另一個類別（稱為父類別或基礎類別）的屬性和方法。子類別可以使用父類別中的屬性和方法，也可以根據需要添加新的屬性和方法。\n通過繼承，子類別可以重用父類別的程式碼，並且可以在不影響父類別的情況下進行擴展。這樣可以提高程式碼的可維護性和可重用性。\n在繼承關係中，子類別可以繼承父類別的公有屬性和方法，而私有屬性和方法則無法被子類別繼承。子類別可以覆蓋（override）父類別中的方法，即在子類別中重新實現該方法，使其具有不同的行為。此外，子類別還可以調用父類別中的方法，這被稱為 super 調用。\n範例說明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Animal def initialize(name, age) @name = name @age = age end def say_hello puts \"Hello, my name is #{@name}.\" end end class Dog \u003c Animal def bark puts \"Woof!\" end end my_dog = Dog.new(\"Max\", 3) my_dog.say_hello # Output: \"Hello, my name is Max.\" my_dog.bark # Output: \"Woof!\"   在這個例子中，Animal 是一個父類別，它有一個初始化方法 initialize 和一個 say_hello 方法。Dog 是一個子類別，它通過 \u003c Animal 表示繼承 Animal，因此它繼承了 Animal 的所有屬性和方法。在 Dog 中添加了一個新的方法 bark，而且 Dog 也可以使用 Animal 的方法 say_hello。透過這個範例，我們可以看到繼承如何在 Ruby 中實現。\nsuper 在 Ruby 中，super 是一個關鍵字，用於調用父類別中與當前方法同名的方法。在子類別中使用 super 可以讓子類別繼承父類別中的相關行為。當子類別需要擴展父類別中的某些方法時，可以在子類別中定義一個與父類別中同名的方法，然後使用 super 關鍵字來調用父類別中的方法，以便在不重複代碼的情況下繼承和擴展父類別的行為。\n範例(super) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class Vehicle def initialize(make, model) @make = make @model = model end def start_engine puts \"#{@make}#{@model}Starting engine...\" end end class Car \u003c Vehicle def initialize(make, model, color) super(make, model) @color = color end def drive puts \"Driving #{@color}car...\" end end class Motorcycle \u003c Vehicle def initialize(make, model, style) super(make, model) @style = style end def ride puts \"Riding #{@style}motorcycle...\" end end my_car = Car.new(\"Toyota\", \"Camry\", \"red\") my_car.start_engine # Toyota Camry Starting engine... my_car.drive # Driving red car... my_motorcycle = Motorcycle.new(\"Harley Davidson\", \"Sportster\", \"cruiser\") my_motorcycle.start_engine # Harley Davidson Sportster Starting engine... my_motorcycle.ride # Riding cruiser motorcycle...   在這個例子中，新增了 Vehicle 類別，讓它包含一個 initialize 方法，接受兩個參數 make 和 model。然後我們創建了兩個子類別，Car 和 Motorcycle，它們繼承自 Vehicle 並定義了它們自己的 initialize 方法。\n在 Car 和 Motorcycle 類別中，我們使用 super 關鍵字來呼叫父類別 Vehicle 的 initialize 方法，並傳遞所需的參數 make 和 model。然後，我們定義了自己的實例變數 @color 和 @style。\n我們創建了這兩個子類別的實例，並呼叫它們各自的方法。這次，當我們創建 Car 和 Motorcycle 的實例時，需要傳遞其 initialize 方法所需的額外參數。當我們在這些對象上調用 start_engine 方法時，它是從父類別 Vehicle 繼承而來。這展示了在 Ruby 中使用繼承和 super 關鍵字的方式。\n","description":"","tags":null,"title":"Inheritance","uri":"/posts/inheritance/"},{"categories":null,"content":"What is “Abstraction” Abstraction refers to the process of simplifying a complex system, data, or computation into a more understandable and manageable model or concept. Through abstraction, programmers can hide unnecessary details in a system and provide a concise and easy-to-use interface for other program modules or users.\nFor example, when designing a library system, we can abstract the concept of “book” without considering the specific details such as size, weight, and shape. This simplifies the system design and provides a clearer interface for users to manage library resources.\nAbstraction is a crucial concept in programming because it can improve code readability, reusability, and maintainability. It is also a core principle in object-oriented programming, where data and operations are separated, and an abstraction layer is provided to hide implementation details.\nThere are several methods to achieve abstraction:\n  Classes: Using classes can encapsulate related data and operations to form an abstract class. Users only need to know the interface and usage of this class without understanding the specific implementation details.\n  Interfaces: Interfaces define a collection of operations that are exposed to the outside. Users only need to know the names and parameters of these operations without understanding the specific implementation details. Interfaces can allow different classes to implement the same operation, achieving code reuse.\n  Abstract classes: Abstract classes are classes that cannot be instantiated. They define an interface and some concrete implementations. Users can use the interface of this abstract class without understanding the specific implementation details.\n  Delegation: Delegation is a mechanism that delegates an operation to another object for execution. This can hide implementation details and only expose necessary interfaces.\n  Generics: Generics is a technique that allows programmers to write generic code. Using generics, code that can handle different types of data can be written, achieving code reuse and abstraction.\n  These are some methods to achieve abstraction, and programmers can choose the most suitable method according to their actual needs.\nAbstraction vs Encapsulation Abstraction and Encapsulation are two different but related concepts in Object-Oriented Programming.\nAbstraction refers to the process of representing complex real-world objects as simpler models, focusing only on the key features and functionalities of the object without considering its implementation details. This helps simplify the system and makes it easier to understand and manage.\nEncapsulation, on the other hand, refers to the technique of hiding the internal details of an object and only exposing the public interface. It groups related properties and methods into a class, and separates them from other classes’ properties and methods. Encapsulation prevents external code from accessing and modifying an object’s properties and methods improperly, improving code security and reliability.\nIn essence, Abstraction focuses on the essence of an object, while Encapsulation focuses on hiding the external interface and internal implementation details of the object. Abstraction and Encapsulation are two fundamental concepts in OOP, and they are often used together.\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Animal attr_reader :name, :species def initialize(name, species) @name = name @species = species end def speak raise NotImplementedError, \"Subclass must implement abstract method\" end end class Cat \u003c Animal def speak \"Meow!\" end end class Dog \u003c Animal def speak \"Woof!\" end end animal = Animal.new(\"ann\", \"pig\") cat = Cat.new(\"Kitty\", \"Felis catus\") dog = Dog.new(\"Rex\", \"Canis lupus familiaris\") puts \"#{cat.name}the #{cat.species}says #{cat.speak}\" # Kitty the Felis catus says Meow! puts \"#{dog.name}the #{dog.species}says #{dog.speak}\" # Rex the Canis lupus familiaris says Woof! puts \"#{animal.name}the #{animal.species}says #{animal.speak}\" # Subclass must implement abstract method (NotImplementedError)   In the above code, the Animal class is an abstract class because it defines a speak method but does not implement it. This is because different animals have different sounds, and we want to implement this method in subclasses. The Cat and Dog classes inherit from the Animal class and implement the speak method. In this example, the Animal class abstracts a real-world concept - animals, while the Cat and Dog classes are concrete implementations.\nThe Animal class encapsulates its two properties - name and species. These properties are defined as instance variables and can only be accessed or modified through defined accessor methods (getter/setter). This prevents external code from directly accessing or modifying the object.\nattr_reader, attr_writer, and attr_accessor can be considered as one way of implementing encapsulation in Ruby. These methods are built-in shortcuts in Ruby that allow developers to easily define getter and setter methods for instance variables, while preventing direct access or modification of instance variables from external code, thus protecting the object’s internal state.\nThe actual effect of these methods is to define a method that allows access to an object’s internal state from outside the object without directly accessing the instance variable of the object. This hides the instance variable and provides a more concise syntax. Encapsulation is one of the important means to achieve high cohesion and low coupling in well-designed object-oriented programs, which can improve the maintainability and readability of the code.\n抽象化是什麼 抽象化（abstraction）是一個將複雜的系統、資料或運算，簡化成一個更易理解、更易處理的模型或概念的過程。透過抽象化，程式設計師可以將系統中不必要的細節隱藏起來，並提供一個簡潔、易於使用的介面，以供其他程式模組或使用者使用。\n舉例來說，當設計一個圖書館系統時，我們可以抽象化出“圖書”這個概念，而不必考慮圖書的具體細節，如大小、重量、形狀等。這樣一來，我們就可以簡化系統的設計，並提供一個更清晰的介面，讓使用者可以更容易地管理圖書館資源。\n抽象化在程式設計中是一個非常重要的概念，因為它可以提高代碼的可讀性、可重用性和可維護性。同時，它也是面向對象程式設計中的核心原則之一，即將資料和操作分離，並提供一個抽象層，以隱藏實現細節。\n  類別：使用類別可以將相關的資料和操作封裝起來，形成一個抽象的類別。使用者只需要知道這個類別的介面和使用方法，而不必了解具體實現的細節。\n  介面：介面定義了一個對外暴露的操作集合，使用者只需要知道這些操作的名稱和參數，而不必了解具體實現的細節。介面可以讓不同的類別實現相同的操作，從而達到代碼的重用。\n  抽象類別：抽象類別是一個不能被實例化的類別，它定義了一個介面和一些具體實現。使用者可以使用這個抽象類別的介面，而不必了解具體實現的細節。\n  委託：委託是一個將一個操作轉交給另一個對象來執行的機制。這樣可以將實現細節隱藏起來，只暴露必要的介面。\n  泛型：泛型是一種可以讓程式設計師編寫出具有一般性的代碼的技術。使用泛型，可以編寫出可以處理不同類型資料的代碼，從而達到代碼的重用和抽象化。\n  以上是實現抽象化的一些方法，程式設計師可以根據實際需求選擇最適合的方法。\n抽象化 vs 封裝 抽象化（Abstraction）和封裝（Encapsulation）是面向對象編程中兩個不同但相關的概念。\n抽象化是指將複雜的現實世界對象抽象成更簡單的模型，僅關注對象的關鍵特徵和功能，而不考慮其實現細節。這樣做有助於簡化系統，使其更容易理解和管理。\n封裝是指隱藏對象的內部細節，只暴露對外的接口。將相關的屬性和方法組成一個類，並將其與其他類的屬性和方法分離開來。封裝可以防止外部代碼不當訪問和修改對象的屬性和方法，提高代碼的安全性和可靠性。\n簡單來說，抽象化關注對象的本質，而封裝關注對象的外部可見接口和內部實現細節的隱藏。抽象化和封裝是OOP中兩個基本的概念，它們通常是一起使用的。\n範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Animal attr_reader :name, :species def initialize(name, species) @name = name @species = species end def speak raise NotImplementedError, \"Subclass must implement abstract method\" end end class Cat \u003c Animal def speak \"Meow!\" end end class Dog \u003c Animal def speak \"Woof!\" end end animal = Animal.new(\"ann\", \"pig\") cat = Cat.new(\"Kitty\", \"Felis catus\") dog = Dog.new(\"Rex\", \"Canis lupus familiaris\") puts \"#{cat.name}the #{cat.species}says #{cat.speak}\" # Kitty the Felis catus says Meow! puts \"#{dog.name}the #{dog.species}says #{dog.speak}\" # Rex the Canis lupus familiaris says Woof! puts \"#{animal.name}the #{animal.species}says #{animal.speak}\" # Subclass must implement abstract method (NotImplementedError)   在上面的代碼中，Animal 類是一個抽象類，因為它定義了一個 speak 方法，但沒有實現它。這是因為不同的動物有不同的叫聲，而我們希望在子類中實現這個方法。Cat 和 Dog 類繼承了 Animal 類，實現了 speak 方法。在這個例子中，Animal 類抽象了一個現實世界的概念 - 動物，而 Cat 和 Dog 類則是具體的實現。\n在 Ruby 中，可以使用實例變量（Instance Variable）和屬性訪問器（Accessor）來實現封裝\nAnimal 類封裝了其兩個屬性 - name 和 species。這些屬性被定義為實例變量，並且只能通過定義的屬性訪問器方法（getter/setter）來訪問或修改。\nattr_reader、attr_writer 和 attr_accessor 可以算是 Ruby 中實現封裝的方法之一。這些方法都是 Ruby 內置的快捷方式，可以讓開發者輕鬆地定義實例變數的 getter 和 setter 方法，同時避免外部程式碼直接訪問或設定實例變數，保護了物件的內部狀態。\n這些方法的實際效果是定義了一個方法，使得可以從物件外部存取對象的內部狀態，而不需要直接訪問物件的實例變數。這樣可以隱藏實例變數，同時提供更簡潔的語法。在設計良好的物件導向程式中，封裝是實現高內聚低耦合的重要手段之一，能夠提高代碼的可維護性和可讀性。\n","description":"","tags":null,"title":"Abstraction","uri":"/posts/abstraction/"},{"categories":null,"content":"What is Object Oriented Programming Object Oriented Programming (OOP) is a software development methodology that models real-world objects and builds software based on how these objects interact with each other.\nIn OOP, objects in software are made up of data properties and methods that operate on that data. These objects can be seen as entities within the software, and they work together to accomplish specific tasks. For example, a bank account object might have properties such as balance and account number, and methods such as deposit and withdraw.\nThe fundamental concepts of OOP are “classes” and “objects”. Classes describe the blueprint or template for objects, and objects are instances created from these classes. In OOP, objects can be made more flexible through concepts such as inheritance and polymorphism, making the code more organized, reusable, and easier to maintain.\nOOP provides a way to break down complex programs into smaller, more manageable parts. By breaking a program into classes and objects, we can create code that is easier to understand, modify, and maintain. Additionally, OOP can increase the reusability of software, as developers can use existing objects to develop new functionality. It is widely used in modern programming languages such as Java, Python, and Ruby, among others.\nThe core concepts of OOP are: 1. Object-oriented programming three features   Encapsulation: Encapsulation is the technique of hiding the internal details of an object and only exposing the public interface. It groups related properties and methods into a class, and separates them from other classes’ properties and methods. Encapsulation prevents external code from accessing and modifying an object’s properties and methods improperly, improving code security and reliability.\n  Inheritance: Inheritance is the mechanism that enables a new object to acquire properties and methods from an existing object. It promotes code reuse and structuring. Inheritance allows the programmer to create new code based on existing code, saving development time and improving code reusability.\n  Polymorphism: Polymorphism refers to the ability of objects to take on multiple forms, where the same operation can behave differently on different objects. Polymorphism allows for flexibility and extensibility, improving code readability, maintainability, and reusability. Polymorphism can be achieved through method overloading, method overriding, and interfaces.\n  2. Object-oriented programming two abstractions:   Abstract: an abstract class cannot be directly instantiated, but can be inherited, and can contain both abstract and implemented methods.\n  Interface: a definition of a set of methods that a class must implement to fulfill the contract.\n   Abstraction: Abstraction is the process of representing complex real-world objects as simpler classes or interfaces, which hides the implementation details and only exposes the object’s functionality and properties. By abstracting objects, the programmer can simplify the system’s complexity, making it easier to understand and manage.\n 3. Good object-oriented programming principles: SOLID  S (Single Responsibility Principle): a class should have only one function. O (Open/Closed Principle): software entities should be open for extension but closed for modification. L (Liskov Substitution Principle): objects of a superclass shall be replaceable with objects of its subclasses. I (Interface Segregation Principle): a client should not be forced to depend on methods it does not use. D (Dependency Inversion Principle): high-level modules should not depend on low-level modules, both should depend on abstractions.  These concepts are interrelated and are usually used together to implement complex code. OOP can help programmers write code that is easy to understand, reuse, and maintain, while improving the quality and productivity of the code.\n什麼是物件導向設計(Object Oriented Programming) Object Oriented Programming (OOP) 是一種軟體開發的方法，它將現實世界中的物件模型化，以物件之間的互動方式來建立軟體。\n在 OOP 中，軟體中的物件由資料屬性和操作資料的方法所構成。這些物件可以被看做軟體中的實體，它們能夠合作來完成特定的任務。例如，一個銀行帳戶物件可以有屬性如餘額、帳戶號碼等，而方法則可以是存款、提款等。\nOOP 的基本概念是「類別」和「物件」。類別是用來描述物件的藍圖或模板，而物件是透過這些類別來建立的實體。在 OOP 中，物件能夠透過繼承和多型等概念來增加彈性，讓程式碼更有組織性、可重複使用性和易於維護性。\nOOP 提供了一種將複雜程式拆解成更小、更易管理的部分的方式。透過將程式拆解成類別和物件，我們可以創建出更容易理解、修改和維護的程式碼。此外，物件導向程式設計也可以增加軟體的可重用性，因為開發者可以使用現有的物件來開發新的功能。它廣泛地應用於現代程式語言，如 Java、Python 和 Ruby 等。\nOOP的核心概念包括： 1. 物件導向三特性：   Encapsulation（封裝）：封裝是一種隱藏物件細節的技術。它將相關的屬性和方法組合起來形成一個類別，同時將其與其他類別的屬性和方法分開。封裝可以防止外部代碼不當地訪問和修改物件的屬性和方法，從而提高代碼的安全性和可靠性。\n  Inheritance（繼承）：繼承是指一個物件可以獲得另一個物件的屬性和方法，從而可以重複利用代碼並實現代碼的結構化。透過繼承，程式設計師可以建立基於現有代碼的新代碼，從而節省開發時間並提高代碼的可重複利用性。\n  Polymorphism（多態性）：多態性是指相同的操作可以作用於不同的物件上，產生不同的行為。它可以實現代碼的靈活性和擴展性，從而提高代碼的可讀性、可維護性和可重用性。多態性是OOP中最重要的概念之一，它可以通過方法重載、方法重寫和介面實現。\n  透過這些核心概念的運用，程式設計師可以寫出易讀、易維護、可重複利用、彈性及可擴充的程式。\n2. 物件導向兩抽象 (Abstraction)  Abstract：抽象類別是不能直接實例化的類別，只能被繼承，且可以包含抽象方法和實作方法。 Interface：介面是一個定義了一系列方法的抽象型別，實現這個介面的類別必須實現所有定義的方法。   抽象化是將具體事物抽象成一個類別或介面，使程式設計師可以隱藏實現細節，只關注物件的功能和特性。透過抽象化，程式設計師可以簡化系統的複雜性，使其易於理解和管理。\n 3. 好的物件導向原則：SOLID  S (Single Responsibility Principle)：單一職責原則，一個類別只負責一個職責。 O (Open/Closed Principle)：開放封閉原則，對擴展開放，對修改封閉。 L (Liskov Substitution Principle)：里氏替換原則，衍生類別必須能夠替換基類別。 I (Interface Segregation Principle)：介面隔離原則，介面應該是客戶端所需要的最小介面。 D (Dependency Inversion Principle)：依賴反轉原則，高層模組不應該依賴低層模組，而是依賴抽象介面。  Example 1 下面是一個簡單的例子，展示如何使用 Ruby 的物件導向程式設計來建立一個簡單的人物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Person attr_accessor :name, :age def say_hello puts \"Hello, my name is #{@name}and I'm #{@age}years old.\" end end # Create a new Person object my_person = Person.new # Set the name and age attributes my_person.name = \"Alice\" my_person.age = 30 my_person.say_hello #\"Hello, my name is Alice and I'm 30 years old.\"   In this example, the Person class defines two attributes using the attr_accessor method: name and age. This automatically creates getter and setter methods for the attributes, so we can set their values using person.name = “Alice” and person.age = 30.\nThe say_hello method uses the name and age attributes to output a message introducing the person. We can call this method on the Person object by using person.say_hello.\nUsing attr_accessor instead of an initialize method can simplify the code for simple cases like this where we just need to define a few attributes for an object.\n這個程式碼定義了一個 Person 類別，該類別具有 name 和 age 兩個屬性以及一個 say_hello 方法。使用 attr_accessor 來定義存取器方法，用於設置和獲取實例變數。在 say_hello 方法中，會顯示一條簡單的消息，顯示人的名字和年齡。\n在這個例子中，我們創建一個名為 my_person 的 Person 物件，並設置其 name 和 age 屬性，最後呼叫它的 say_hello 方法來顯示人的資訊。\n使用 attr_accessor 而不是 initialize 方法可以簡化像這樣的簡單情況的代碼，我們只需要為一個對象定義一些屬性。\nExample 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person attr_accessor :name, :age def initialize(name, age) @name = name @age = age end def introduce puts \"Hi, my name is #{@name}and I'm #{@age}years old.\" end end person1 = Person.new(\"John\", 30) person2 = Person.new(\"Jane\", 25) person1.introduce person2.introduce   In this example, the Person class has an initialize method that takes two parameters, name and age. These parameters are used to set the instance variables @name and @age, respectively. The attr_accessor method is used to define getter and setter methods for these instance variables.\nThe introduce method is used to print out a message introducing the person by name and age. Two instances of the Person class are created with the new method, and the introduce method is called on each of them to introduce them.\nExample 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Game def initialize @number = rand(1..100) @guesses = 0 @game_over = false end def play puts \"Let's play a guessing game!\" until @game_over guess = get_guess check_guess(guess) end end private def get_guess puts \"Enter a number between 1 and 100:\" gets.chomp.to_i end def check_guess(guess) @guesses += 1 if guess == @number puts \"Congratulations, you guessed the number in #{@guesses}tries!\" @game_over = true elsif guess \u003c @number puts \"Sorry, that's too low. Guess again.\" else puts \"Sorry, that's too high. Guess again.\" end end end game = Game.new game.play   In this example, we define a Game class to represent a guessing game. In the initialize method, we use the rand method to generate a random number between 1 and 100, and initialize some game-related variables such as the number of guesses (@guesses) and whether the game is over (@game_over).\nIn the play method, we use a until loop to keep getting guesses from the player until the game is over. In each guess, we call the get_guess method to get a number from the player, and then call the check_guess method to check whether the guess is correct.\nIn the get_guess method, we use the puts method to print a prompt message, and the gets method to get input from the player. In the check_guess method, we first increment the number of guesses, and then check whether the guess is correct. If the guess is correct, we print a congratulatory message and set @game_over to true. Otherwise, we print a message telling the player whether the guess was too high or too low.\nFinally, we create a Game object and call the play method to start the game. Each time the player enters a number, the game tells the player whether the guess was correct or not.\nExample 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person attr_accessor :name, :age, :gender def initialize(name, age, gender) @name = name @age = age @gender = gender end def say_hello puts \"Hi, my name is #{@name}. I'm #{@age}years old and #{@gender}.\" end end # 創建一個人物件 person1 = Person.new(\"David\", 25, \"male\") # 訪問和修改屬性 puts person1.name # David person1.age = 30 puts person1.age # 30 # 呼叫方法 person1.say_hello # Hi, my name is David. I'm 30 years old and male.   這個例子中，我們定義了一個 Person 類別，這個類別具有 name、age 和 gender 三個屬性，以及一個 say_hello 方法。在創建一個人物件時，我們需要提供姓名、年齡和性別等屬性值。我們可以通過使用 attr_accessor 簡化屬性的定義，並使用 initialize 方法來初始化屬性值。在 say_hello 方法中，我們使用實例變數 @name、@age 和 @gender 輸出人物件的屬性值。\n這個例子展示了如何使用 Ruby 物件導向程式設計來建立一個簡單的人物件，並演示了如何訪問和修改物件的屬性，以及如何呼叫物件的方法。\nExample 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Dog def initialize(name, breed) @name = name @breed = breed end def bark puts \"Woof! My name is #{@name}and I'm a #{@breed}.\" end end # 創建一個名為 Spot，品種為柴犬的狗物件 my_dog = Dog.new(\"Spot\", \"Shiba Inu\") # 使用 bark 方法讓狗叫 my_dog.bark   這個程式定義了一個 Dog 類別，該類別有一個 initialize 方法用來初始化名稱和品種的實例變數，以及一個 bark 方法，該方法會讓狗顯示它的名字和品種。程式還創建了一個 my_dog 物件實例，該物件代表一隻名為 “Spot” 的柴犬，然後使用 bark 方法讓狗叫。\nExample 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Car def initialize(make, model, year) @make = make @model = model @year = year @speed = 0 end def speed_up(num) @speed += num puts \"The car is now going #{@speed}mph.\" end def brake(num) @speed -= num puts \"The car is now going #{@speed}mph.\" end def shut_off @speed = 0 puts \"The car is now off.\" end end # 創建一個名為 my_car 的 Car 物件實例 my_car = Car.new(\"Toyota\", \"Camry\", 2015) # 使用 speed_up 方法增加汽車的速度 my_car.speed_up(20) # 再次使用 speed_up 方法增加汽車的速度 my_car.speed_up(30) # 使用 brake 方法減少汽車的速度 my_car.brake(10) # 使用 shut_off 方法關閉汽車 my_car.shut_off   這個程式定義了一個 Car 類別，該類別有一個 initialize 方法用來初始化汽車的屬性（品牌、型號、年份、速度），以及三個方法 speed_up、brake 和 shut_off。這些方法可以讓汽車加速、減速和關閉。程式還創建了一個 my_car 物件實例，該物件代表一輛品牌為 Toyota，型號為 Camry，年份為 2015 的汽車，然後使用 speed_up、brake 和 shut_off 方法操作該汽車的速度和狀態。\nExample 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  class Account attr_reader :balance, :name def initialize(name, balance = 0) @name = name @balance = balance end def deposit(amount) @balance += amount end def withdraw(amount) if amount \u003e @balance puts \"Error: insufficient balance.\" else @balance -= amount end end end class Bank def initialize @accounts = [] end def create_account(name, balance = 0) @accounts \u003c\u003c Account.new(name, balance) end def get_account(name) @accounts.each do |account| if account.name == name return account end end return nil end end my_bank = Bank.new my_bank.create_account(\"Alice\", 1000) my_bank.create_account(\"Bob\", 500) alice_account = my_bank.get_account(\"Alice\") bob_account = my_bank.get_account(\"Bob\") puts alice_account.balance # 輸出 1000 puts bob_account.balance # 輸出 500 alice_account.withdraw(200) puts alice_account.balance # 輸出 800 bob_account.deposit(100) puts bob_account.balance # 輸出 600 alice_account.withdraw(1000) # 輸出 \"Error: insufficient balance.\"   在這個範例中，我們建立了兩個類別（Class），分別是 Account 和 Bank。Account 類別表示一個銀行帳戶物件，它有一個名字（name）和一個餘額（balance）。Bank 類別表示一個銀行系統物件，它可以創建帳戶（create_account）和查詢帳戶（get_account）。\n在 Account 類別中，我們定義了三個方法，分別是 initialize、deposit 和 withdraw。initialize 方法用於初始化一個帳戶，deposit 方法用於存款，withdraw 方法用於取款。在 withdraw 方法中，我們判斷取款金額是否超過帳戶餘額，如果是，就輸出一個錯誤訊息。\n在 Bank 類別中，我們定義了兩個方法，分別是 initialize、create_account 和 get_account。initialize 方法用於初始化一個銀行系統物件，create_account 方法用於創建一個帳戶，get_account 方法用於查詢一個帳戶。\n接著，我們使用 new 方法創建了一個 Bank 物件，並將它儲存在 my_bank 變數中。我們可以使用 my_bank 這個變數，來創建帳戶和查詢帳\n","description":"","tags":null,"title":"Object Oriented Programming","uri":"/posts/oop/"},{"categories":null,"content":"What is “Polymorphism” Polymorphism is a concept in object-oriented programming that refers to the ability of an object to take on many forms or have multiple behaviors. Specifically, it allows different objects to be treated as if they were the same type of object, even if they are different. This means that the same method or operation can be used on different objects, and each object will behave differently based on its own internal implementation.\nPolymorphism is typically achieved through inheritance and method overriding, which allows a subclass to override the implementation of a method inherited from its superclass. This means that different subclasses of the same superclass can have different behaviors for the same method, and can therefore be treated as if they were the same type of object.\nPolymorphism is a key concept in object-oriented programming, as it allows code to be written in a more general and reusable way. By treating objects as if they were the same type of object, code can be written that is more modular, flexible, and easier to maintain, since it can be used with different types of objects without modification.\nExample with Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Animal def speak puts \"I am an animal\" end end class Dog \u003c Animal def speak puts \"Woof!\" end end class Cat \u003c Animal def speak puts \"Meow!\" end end animals = [Animal.new, Dog.new, Cat.new] animals.each do |animal| animal.speak end # Prints I am an animal # Prints Woof! # Prints Meow!   In this example, we define an Animal class and two subclasses Dog and Cat, both of which override the speak method. We also define an array animals that contains instances of the Animal, Dog, and Cat classes.\nIn the loop, we pass each object in the animals array as an argument to the speak method. Since each object is an instance of a different class, they will exhibit different behaviors. When the Animal object calls the speak method, it will output “I am an animal”; when the Dog object calls the speak method, it will output “Woof!”; when the Cat object calls the speak method, it will output “Meow!”.\nThis example demonstrates how polymorphism can be used to implement different behaviors for different objects. Since the Dog and Cat classes both inherit from the Animal class, they both have a speak method, but the implementation of this method is different. When we call the speak method, Ruby automatically chooses the appropriate method based on the actual type of the object. This is the essence of polymorphism.\nExample with JavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Vehicle { move() { console.log(\"I'm moving\"); } } class Plane extends Vehicle { move() { console.log(\"I'm flying\"); } } class Boat extends Vehicle { move() { console.log(\"I'm on the water\"); } } class Car extends Vehicle {} const vehicle = new Vehicle(); const plane = new Plane(); const boat = new Boat(); const car = new Car(); vehicle.move() // Prints I'm moving plane.move() // Prints I'm flying boat.move() // Prints I'm on the water car.move() // Prints I'm moving   多型是什麼? 多型（polymorphism）是面向物件程式設計（OOP）的一個概念，它允許不同的物件具有相同的介面（方法或屬性），但表現出不同的行為。換句話說，多型是指在不同的情境中，同一個實體（例如一個類別的實例）可以表現出不同的形態和行為。\n多型的實現方式有很多種，其中最常見的是方法重載（method overloading）和方法重寫（method overriding）。方法重載是指在一個類別中定義多個方法，這些方法具有相同的名稱，但是參數類型或數量不同。當調用這些方法時，編譯器會根據實參的類型和數量自動匹配到對應的方法。方法重寫則是指子類重寫父類的方法，在子類中定義一個和父類方法簽名相同的方法，但是實現不同的行為。\n多型是面向物件程式設計的重要特性之一，它可以讓程式更加靈活、可擴展和易維護。通過多型，我們可以編寫通用的程式碼，而不需要針對每個具體的物件編寫不同的程式碼。\n在 Ruby 中，多型通常是通過方法重寫（method overriding）來實現的。上面第一個例子是一個簡單的 Ruby 範例，展示了如何使用多型來實現不同物件的不同行為：\n在這個例子中，我們定義了一個 Animal 類別和兩個子類別 Dog 和 Cat，它們都重寫了 speak 方法。我們還定義了一個陣列 animals，裡面包含了 Animal、Dog 和 Cat 類別的實例。\n在迴圈中，我們將 animals 陣列中的每個物件作為參數傳遞給 speak 方法。由於每個物件都是不同的類別實例，所以它們將表現出不同的行為。當 Animal 物件調用 speak 方法時，它將輸出 “I am an animal”；當 Dog 物件調用 speak 方法時，它將輸出 “Woof!\"；當 Cat 物件調用 speak 方法時，它將輸出 “Meow!\"。\n這個例子展示了如何使用多型來實現不同物件的不同行為。由於 Dog 和 Cat 類別都繼承自 Animal 類別，它們都有一個 speak 方法，但是這個方法的實現是不同的。當我們調用 speak 方法時，Ruby 會根據物件的實際類型自動選擇適當的方法。這就是多型的本質。\n","description":"","tags":null,"title":"Polymorphism","uri":"/posts/polymorphism/"},{"categories":null,"content":"Week 1 and 2 the Golden Square challenges  Learn to test-drive programs with multiple classes. Learn to break programs up into classes. Learn to debug your programs. Learn to build software as a pair. Learn to explain why test-driving, object-oriented design, debugging, and pairing are powerful practices for software engineers.  Goal  I can TDD anything I can program fluently I can debug anything  Week 3 Databases challenges  Design a database schema with at least two tables from a specification, including a one-to-many relationship between two tables, and create the schema in a database using SQL. Use SQL to query a database to read data from one table or resulting of a join, create new records, update and delete. Integrate a relational database to a program by test-driving classes which implement CRUD methods to send SQL queries to a database.  Week 4 Web applications challenges  Explain how HTTP requests and responses work at a high level Write integration tests for a web application Implement web routes using a lightweight web framework Follow a debugging process for a web application Deploy a web application using a light cloud service such as Heroku  ","description":"","tags":null,"title":"Month1 at Makers","uri":"/posts/month1_at_makers/"},{"categories":null,"content":"Week 1 Peer 9.30am we meet with our peer groups. These should run stand-up style to discuss what we did yesterday and intend to do today, as well as a source of connection and support.\nWeek 1 peer group check-in topic Tues\n What do you think a peer group is for? What do you want to use your peer group for?  Wed\n What’s a priority in your life?  Thurs\n What traits in a person do you find challenging? How do you usually handle it?  Fri\n Name a highlight and a challenge that you experienced this week? How did you deal with the challenge?  The Golden Square Challenges (Solo \u0026 Pairs) Phase One: Testing Bites Work through this series of exercises designed to help you learn how to write tests with RSpec.\n Testing Methods With Equality (Exercise One, Exercise Two, Challenge) Testing Classes With Equality (Exercise One, Ecercise Two, Challenge) Testing For Errors (Exercise, Challenge)  Phase Two: Skill Challenges Work through this series of challenges designed to help you learn a strong test-driving, object-oriented design, and debugging practices.\nSome of these challenges include Process Feedback Challenges, in which you record yourself performing the task and share it with your coach for feedback. These are tagged with a 📡.\n Create Your Project Test Drive a Single-Method Program(Exercise, Challenge) Design a Single-Method Program 📡(Design single method recipe template, Exercise One, Exercise Two recipe, Exercise Two, Challenge recipe, Challenge) Intermezzo: Debugging 1(Exercise One, Exercise Two, Challenge) Test Drive a Class(Exercise, Challenge) Design a Class 📡(Design a class recipe template, Exercise recipe, Exercise, Challenge recipe, Challenge) Intermezzo: Debugging 2(Exercise, Challenge)  Notes    Password Checker (Challenge from Testing for errors)    1 2 3 4  it \"should return NoMethod erron when the password is integer\" do password_checker = PasswordChecker.new expect{password_checker.check(123)}.to raise_error(NoMethodError) end   Which can pass the test, but the below is not:\n1 2 3 4 5  it \"should return NoMethod erron when the password is integer\" do password_checker = PasswordChecker.new result = password_checker.check(123) expect{result}.to raise_error(NoMethodError) end   The reason is the result will be assign to “NoMethodError”, so that can not go to the next step. But the first one we catch the error at the mean time.\n  Gratitudes(Challenge from Testing Classes with Equality)    1 2 3 4 5 6  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new gratitude.add(\"sunshine\") result = gratitude.format expect(result).to eq \"Be grateful for: sunshine\" end   Which can pass the test, but the below is not:\n1 2 3 4 5  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new result = gratitude.add(\"sunshine\").format expect(result).to eq \"Be grateful for: sunshine\" end   The reason is because the format method which is defined by ourself, we can not use it in the chain method. If we use the method which ruby defined already, which should be fine. Rewrite like this:\n1 2 3 4 5  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new result = gratitude.add(\"Sunshine\").push(\"hi\").join(\" \") expect(result).to eq \"Sunshine hi\" end   And it pass the test.\n","description":"","tags":null,"title":"Week1 at Makers","uri":"/posts/week1_at_makers/"},{"categories":null,"content":"Schedule for the first day    Time What     09.45 - 10.45 Welcome to Makers   10.45 - 11.00 BREAK   11.00 - 12.30 Life at Makers by Dana, our Chief Joy Officer   12.30 - 14.00 LUNCH BREAK   14.00 - 15.45 Succeeding at Makers, and beyond…   15.45 - 16.00 BREAK   16.00 - 16.45 Meet the Coaches   16.45 - 17.00 BREAK   17.00 - 17.30 Social time (optional)    Notes (Life at Makers by Dana)  Ask for help, help each other Emotional Intelligence EI EQ Train attention Meditation Mindfulness could be a gym of your brain Neuroplasticity  Notes (Meet the Coaches)   Asking question\n  Putting 100 % in it, but don’t be too stress and worry at should complete it with every details\n  The EQ workshop and meditation really work.\n  Be nice to yourself don’t assume you are the only one have the negative feeling\n  Ask yourself do you know more yesterday, if yes, then you are absolutely on the right process.\n  Do you have fun, enjoy it? Have fun and enjoy it rather then stress.\n  Keep coding, if you feeling don’t want to code anymore, come and talk with the coach.\n  Try it! TDD!\n  It’s tough and uncomfortable, but once you have confident to broke down everything, you can solve the problem.\n  Shared and asked in your cohort channel as possible! How you solve the problem, how you work.Sharing knowledge and you are helping each other.\n  There is lots of skills like problem solving, communication skills matter with career, it’s not only coding\n  Connecting with anyone and help everyone.\n  ","description":"","tags":null,"title":"First day at Makers","uri":"/posts/first_day_at_makers/"},{"categories":null,"content":"Array  Remove Duplicates from Sorted Array  1 2 3 4  def remove_duplicates(nums) nums.uniq! return nums.length end   解法 使用 uniq 篩選出陣列中的不重覆數值並使用!改變原始陣列。 再使用 length 算出陣列長度\nBest Time to Buy and Sell Stock II  1 2 3 4 5 6 7  def max_profit(prices) max_profit = 0 prices.each_cons(2) do |price, next_price| next_price \u003e price \u0026\u0026 max_profit = next_price - price + max_profit end max_profit end   解法\nRotate Array  1 2 3  def rotate(nums, k) nums.rotate!(-k) end   解法 把 nums 使用 rotate 輸轉陣列並使用!改變原始陣列(移動 (-k))\n","description":"","tags":null,"title":"Leetcode","uri":"/posts/leetcode/"},{"categories":null,"content":"RUBY 一、symbols 字串符號 唯一且不會變動的識別名稱 效能比較好，不需要額外的空間來儲存\n字串物件(string)每次都會更新記憶體位置，效能不如symbols但優點是有許多方法可以使用如: reverse, size, downcase\n二、 問號跟驚嘆號\n在 ruby 定義方法時，問號跟驚嘆號也是方法的一部分。\n一般使用問號時，慣例上是表示這個方法會回傳布林值 (true 或 false)\n使用驚嘆號，通常是表示這個方法可能會有「副作用」或「驚喜」，例如陣列有個叫做 uniq 的方法，它可以產生一個元素不重覆的新陣列。\nuniq 方法會回傳一個新的陣列回來，不影響原來的資料\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq p original_list [1, 3, 4, 2, 5, 2, 3] p uniq_list [1, 3, 4, 2, 5]   但如果你是使用有驚嘆號版本的 uniq! 就不同了，原本的陣列也被改變了。\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq! p original_list [1, 3, 4, 2, 5] p uniq_list [1, 3, 4, 2, 5]   三、join、split join 用於將陣列( array )中的元素( element )轉成字串( string )。\nsplit 用於將字串( string )轉成陣列( array )\n四、module 與 modle\n五、namespace\nRails 一、型態 text(文字) 與 string(字串)\ntext 是一種二進位，binary 的格式。可以放的字非常多，可能幾千、幾萬個字，可以使用在如文章內文\nstring 能放的字比較少，使用在文字不會太長的情況，例如文章標題\n二、什麼是 migration\n一種描述資料表該長什麼樣子的描述檔，可以漸進式的去修改你的資料表\n優點: 有紀錄，是一連串的檔案，為資料表的演進過程(欄位變化，新增修改刪除) 可以進行版本控制\n如果要使 migration 具現化，在終端機下指令：\nrails db:migrate 三、CSRF 攻擊\nCSRF (Cross-site request forgery)，跨站請求偽造。目的不一定是要取得使用者帳戶的控制權或個資，但可以用其他使用者的名義執行某些操作。\n這類攻擊的特點是以使用者身份發起\n例如，駭客想刪掉某個 Blog 平台的文章，雖然他沒有這個網站的使用權限，但猜到了後台的路徑: /admin/posts/1便可以使用 delete 方法來刪除。接著把這個連結包裝成中獎資訊，寄送給有權限且剛好處於登入狀態的 X 先生，當 X 先生點下連結，文章就會透過 X 先生的權限來刪除了。\n這個例子中，CSRF 攻擊之所以可以成功，並不是因為駭客獲取 X 先生 的 cookie 資訊，而是偽裝成是 X 先生。\n解決方法:\n 檢查 referer 欄位 (可透過檢查 Header 中的 Referer 欄位是否存在及是否為正常流程網域，藉此確認發送端的前一個頁面是否被偽造或合法使用。) 加入驗證 token (除了驗證 Cookie 的 Token 之外，還需另外在 Request 中放入隱藏的動態 Token 參數。等同於要求每次的 Request 都必須帶上密碼)  四、什麼是 erb 檔 可以在 HTML 裡面寫 ruby 的程式碼。ERb其實可以用來產生任何文字檔格式，例如CSV、XML、JavaScript等等\n五、N+1\nN+1 指的是 SQL 撈資料時，明明可以一次撈完 (例如要三筆資料)，卻使用逐筆撈資料的方式處理 (每次只撈一筆資料) 1次查詢 + N 次的關聯資料查詢就會讓資料庫效能損失\n解決方法: 查詢資料的過程中，使用includes多撈一點資料回來。變成 1 + 1\n六、中控台模式 rails console\nrails c 可在裡面修改資料及查詢資料。 跟 irb 本質上沒有太大差別，中控台模式會把整個 rails 環境，包含相關model 、相關套件整個載下來。\n而 irb 就是一般 ruby 環境\n七、ORM\nObject Relational Mapping\n目的: 簡化資料庫操作語法\n透過物件的方式，去操作資料表，再換句話說， 把物件導向的語法，透過model，轉換成 SQL 查詢語句，對開發人員來說輕鬆很多。撈回來的資料再交給 model 物件化\n例如: Book.all 等同於 select * from books\n SQL 可以被 ORM 取代嗎？\n 當遇到問題時，比如效能，還是需要在 log (紀錄) 裡看 SQL 的語法，看是否寫錯造成翻譯錯誤。 複雜的查詢還是必須使用 SQL 語法   ORM 基本操作 CRUD\nC new 新增一筆資料 create 新增一筆資料，並寫進資料庫 (寫入失敗時默默 rollback) create! 同上，但寫入失敗時會噴錯誤訊息 (可使用 beging rescure 捕捉) R first 找出第一筆資料 last 找出最後一筆資料 find:找出單一筆資料，且只能透過id去搜尋。找不到時 find 會噴錯誤訊息 (例外訊息) find_by 找出單一筆資料，且可以透過自訂條件去搜尋。找不到時 find_by 會回傳的值是nil find_each 資料量大時，預設每次抓 1000 筆 all 找出所有資料 select(’name’) 同上，但只選取 name 欄位 where(name: ‘Happy’) 找出所有 name 欄位是 Ruby 的資料 order(‘id DESC’) 依照 id 大小反向排序 order(id: :desc) 同上 limit(3) 只取出 3 筆資料 count average sum maximum 與 minimum U update update_all increment 欄位的值 + 1 (沒有存檔功能，要記得 save) toggle 把原本的 true / false 值對調 (沒有存檔功能，要記得 save) D delete destroy 刪的過程中，有一連串的 callback destroy_all\nScope\n把商業邏輯寫到 model 裡 取代 controller 一堆 where 是一種類別方法\n八、 MVC\nMVC 架構 Model View Controller\n流程: 一個使用者，透過 route(第一線處理 request 的角色，在 rails 裡非常重要) 導到某一個controller，也許需要調資料(跟model)，也許不用。查完之後(如果需要查詢的話)把資料交還給controller，用 view 去做頁面呈現 (HTML \u0026 CSS)\nModel: 抽象層的概念 model 不是資料表，資料表是 table (實體存在的東西)\nController: 本身是一個 class ， 一個一個的 action 就是方法\nView: 在 controller acton (透過 model 向資料庫) 拿到的 raw data，搭配畫面跟表單，組成一般使用者可以讀的表格、表單\n優點∶ 歸類整齊，易於前後端分工 流程控制: controller 資料邏輯: model 畫面相關: view\n View 技術上來說，其實是會回傳 HTML 內容的方法(method、function)\n 九、資料驗證 前端驗證: 還沒送出去前，在表單用 JavaScript擋下來，缺點驗證是容易被避開 後端驗證: 寫進資料庫之前，如果內容沒填、格式有問題等，把它擋下來。\n在 model 層，比如名字欄位必填，可以使用以下的驗證器\n1  validates :name, presence: true   其他在 rails guide 的 Validation Helpers 還有更多可以使用的驗證\n不寫在 controller 的原因，每一個 controller 要寫去都要做檢查\nmodel 是整包做檢查\n 若同時有不同系統存取資料庫的狀況(比如PHP)，則無法保證資料一定無誤。這時可以在資料庫本體擋掉，比較安全\n  如何繞過驗證 c.save(validate: false)\n 十、 Callback\n資料存檔的流程會經過以下流程: save \u003e valid \u003e before_validation \u003e validate \u003e after_validate \u003e before_save \u003e before_create \u003e create \u003e after_create \u003e after_save \u003e after_commit\nbefore_save 資料寫進跟更新都會執行 before_create 資料被建立的時候才會執行\n十一、 Active Record\n是一種設計模式，本身是一個物件。 每一筆資料包裝成一個物件，並在其增加資料操作邏輯，讓資料的存取更便利\n這個物件，由欄位、基本操作、商業邏輯組成\n我們可以說 MVC 裡的 Model = 依照 Active Record 模式設計的產物\n而 Active Record 是一種 ORM 框架\nActive Record ORM Model Database Table\n十二、二大哲學\n(一) 慣例優於設定 Convention Over Configuration(CoC) 慣例 = 可以少寫不必要的程式碼 學習 Rails ，等於是在學習 Rails 的慣例 例如:\n Model: 大寫、單數 Table: 小寫、複數 每個表格預設會有一個叫做 id 的流水編號欄位 在 migration 裡預設會有個 timestamps，在具現化的時候，會轉換成 created_at updated_at這兩個時間欄位，在資料新增或更新的時候自動寫當下時間 model 跟 table 的對應 pluralize 找出複數名詞的方法 singularize 找出單數名詞的方法 比如  \"person\".pluralize =\u003e \"people\" \"people\".singularize =\u003e \"person\"  若需自定義，在config/initializers/inflections.rb設定\n 檔案跟 model 的對應。類別名稱由兩個以上的單字組成時，Model 名稱應要遵循 Ruby 的命名慣例，採用駝峰式命名，而資料表名稱必須採用底線分隔。 underscore變成蛇式的方法 camlize變成駝峰式 比如  \"HappyHour\".underscore =\u003e \"happy_hour\" \"happy_hour\".camlize =\u003e \"HappyHour\" 外鍵 - 應用資料表的單數形加上 _id 來命名，比如 item_id, order_id。Active Record 會在你建立 Model 之間的關聯時，尋找這種形式的欄位 singularized_table_name_id。  當 model 之間的關連不是用慣例時，必須加上 foreign_key\n比如有一個 store 的 model:\n1  belongs_to :owner #foreign_key: 'owner_id'   foreign_key 是遵循慣例，所以後面可以省略，但如果是接手別人案子或設計，可能原本不是用 ruby 或 rails 寫的，則需寫出 foreign_key 如下\n1  belongs_to :owner foreign_key: 'u_id'    主鍵(流水編號欄位id) - Active Record 預設會使用一個叫做 id 的整數欄位，作為資料表的主鍵。採用 Active Record migration 來建立資料表時，這個欄位會自動產生。\n  參照值\n  user:references 會造出 user_id 這個數字型態欄位 會指向 user 這個 model 的主鍵(流水編號欄位id)\n(二) Don’t repeat yourself\n十三、關聯性\n一對一、一對多、多對多 has_one 不是設定，它是一個類別方法，例子中的 store 是它的參數 執行 has_one 後，會動態做出四個方法，比如\n1 2 3 4 5 6 7  has_one :store #做出以下的方法 #store #store= #build_store(不會直接寫進資料庫) #create_store    1 2 3 4 5  belongs_to :owner #做出以下的方法 #owner #owner=   1 2 3 4 5 6 7  has_many :books #做出以下的方法 #books #books= #build #create   十四、 include、extend、reuqire、load\ninclude：include是用於向類中包含模組的關鍵字。它將指定的模組中的方法添加到類的實例中，使其可以調用模組中的方法。\nextend：extend也是用於向類中包含模組的關鍵字，但是它將指定的模組中的方法添加到類本身中，使得該類可以調用模組中的方法。\nrequire：require是用於加載其他 Ruby 文件中的程式碼。它可以將其他文件中的類、方法和變量加載到當前文件中。如果該文件已經加載過了，require將不會再次加載。\nload：load也是用於加載其他 Ruby 文件中的程式碼。它和require的區別在於，load每次都會重新加載指定的文件，即使該文件已經加載過了。\ninclude vs extend \n十五、API\n十六、RESTful\n十七、CACHE 暫存\n十八、 Active Job 背景工作\n十九、 前端的 partial 和 helper 差別\n二十、Gemfile 的用意？\n二十一、 namespace\n","description":"","tags":null,"title":"Ruby on Rails 面試題準備","uri":"/posts/interview/"},{"categories":null,"content":"LICEcap可錄製畫面直接存成gif 在專案的使用上非常方便，可以馬上呈現出你製作的功能，讓一起開發的組員一目瞭然。\nMac跟Windows都可以使用 官網下載\nMac使用者記得下載後，到 系統偏好設定 -\u003e 安全性與隱私權 -\u003e 螢幕錄製 裡\n把LICEcap打勾(反灰不能編輯時請按視窗左下角的鎖頭，即可登入權限編輯)\n","description":"","tags":null,"title":"好用工具 LICEcap","uri":"/posts/licecap/"},{"categories":null,"content":"多國語系設置 step. 1 更改預設\nRails 支持多國語系(Internationalization，簡稱I18n)，預設的語系是英文，如要修改，請至config/application.rb\n1 2  config.i18n.available_locales = [:en, :'zh-TW'] #支援語系 config.i18n.default_locale = :'zh-TW' #預設語系   step. 2 新增詞匯檔\n接著，在config/locales新增zh-TW.yml 這個詞匯檔\n1 2  zh-TW:welcome:\"歡迎\"  修改首頁index.html如下\n1  \u003ch1\u003e\u003c%= t('welcome') %\u003e\u003c/h1\u003e   便可以看到首頁的\"welcome\"變成\"歡迎\"\n 檔案副檔名YML是一種YAML Document，格式的縮排必須使用兩個空格\n step. 3 新增Gem\n在Gemfile新增gem \"rails-i18n\" 接著bundle install\nstep. 4 Model字段翻譯\n1 2 3 4 5 6 7 8 9  zh-TW:welcome:\"歡迎\"activerecord:models:feedback:\"回饋\"attributes:feedback:author:\"你的名字\"message:\"訊息\"  就有英文介面及中文介面\nstep. 4 切換多國語系\n 在app/controllers/application_controller.rb新增以下這段  1 2 3 4 5 6 7 8 9 10 11  before_action :set_locale def set_locale if params[:locale] \u0026\u0026 I18n.available_locales.include?( params[:locale].to_sym ) session[:locale] = params[:locale] end I18n.locale = session[:locale] || I18n.default_locale end   接著在app/views/layouts/application.html.erb新增路徑  1 2  \u003c%= link_to \"中文版\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"zh-TW\" %\u003e \u003c%= link_to \"English\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"en\" %\u003e   就可以在頁面看到中文版跟英文版的切換了！\n","description":"","tags":null,"title":"Rails I18n","uri":"/posts/rails_i18n/"},{"categories":null,"content":"用Rails串接第三方支付 MVC\nM = Model 產生訂單的邏輯，比如\n  驗證 validates(使用者名字、金額、訂單編號username 、amount、 order_no)\n  before_create 在本例中是定義build_order_no這個方法\n  enum 在本例中是使用在付款方式的值設定pay_type)\n  V C = Controller 流程控制(產生東西、做什麼事情)\n before_create : 在 rails model 的callback，代表這筆資料被建立的時候我要做什麼事情，呼叫什麼方法。接著可以自己定義方法來使用。 enum : 列舉\n ","description":"","tags":null,"title":"Rails Payment Gateway","uri":"/posts/rails_payment_gateway/"},{"categories":null,"content":"在 rails 上使用 devise 套件 step 1. 在Gemfile加上\ngem 'devise' 或是在該目錄的終端機使用指令% bundle add 'devise'\nstep 2.\n% bundle install step3.\n% rails g devise:install 就會幫我們生成兩個在config下面的檔案\nconfig/initializers/devise.rb config/locales/devise.en.yml 接著在終端機的畫面同時顯示需要完成的指令:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  Some setup you must do manually if you haven't yet: 1. Ensure you have defined default url options in your environments files. Here is an example of default_url_options appropriate for a development environment in config/environments/development.rb: config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } In production, :host should be set to the actual host of your application. 2. Ensure you have defined root_url to *something* in your config/routes.rb. For example: root to: \"home#index\" 3. Ensure you have flash messages in app/views/layouts/application.html.erb. For example: \u003cp class=\"notice\"\u003e\u003c%= notice %\u003e\u003c/p\u003e \u003cp class=\"alert\"\u003e\u003c%= alert %\u003e\u003c/p\u003e 4. You can copy Devise views (for customization) to your app by running: rails g devise:views   一步一步的按照指令完成。\nstep 4.\n% rails g devise User 這個指令會幫我們生成一個migration檔 (db/migrate/20220423155313_devise_create_users.rb) 以及一個新的model檔(app/models/user.rb), 還有在routes.rb新增路徑divise_for :users\nstep 5. 更新資料庫\n% rails db:migrate step 6. 確認路徑\n% rails routes 找出user的路徑\n% rails routes | grep user 可以看到各路徑對照的行為，比如:\n1 2 3  new_user_session (sign_in) destroy_user_session (sign_out) new_user_registration (sign_up)   step 7. sign_up\n在終端機輸入rails s\n開啟http://localhost:3000/users/sign_up 就可以看到註冊頁面了\nstep 8. 清掉cookies\n註冊之後，因為目前的頁面還沒有做sign_out的連結，所以再輸入一次http://localhost:3000/users/sign_up會看到訊息:You are already signed in. 這時候的你，可以打開開發者工具中的Application的Cookies，把該檔案名稱對應的值刪掉，就可以清掉記錄進入到sign_up頁面\nstep 9. Bulma\n參考https://bulma.io/documentation/overview/ 下載Bulma，把樣式表插入app/views/laywout資料夾中的application.html.erb\n1  \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css\"\u003e   接著還要在同個檔案新增meta tag\n1  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e   step 10. 新增navbar 在 app/views 新增shared資料夾，並在裡面新增_navbar.html.erb檔，接著回到laywout的application.html.erb，在body的地方把剛剛的檔案渲染。\n1  \u003c%= render 'shared/navbar' %\u003e   step 11. 編輯navbar\n回到_navbar.html.erb檔，把BULMA的Basic Navbar樣式貼上去，再按照自己的需求編輯:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cnav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\"\u003e \u003cdiv class=\"navbar-brand\"\u003e \u003ca class=\"navbar-item\" href=\"https://bulma.io\"\u003e \u003cimg src=\"https://bulma.io/images/bulma-logo.png\" width=\"112\" height=\"28\"\u003e \u003c/a\u003e \u003ca role=\"button\" class=\"navbar-burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"navbarBasicExample\"\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e (過長省略，程式碼在: https://bulma.io/documentation/components/navbar/)   step 12. 新增sign_up、sign_out、sign_in連結在_navbar.html.erb檔\n1 2 3 4 5 6 7 8 9  \u003c% if  user_signed_in? %\u003e \u003c%= link_to 'Sign out', destroy_user_session_path, method: :delete, class: \"button is-primary\" %\u003e \u003c% else  %\u003e \u003c%= link_to 'Sign up', new_user_registration_path, class: \"button is-primary\" %\u003e \u003c%= link_to 'Log in', new_user_session_path, class: \"button is-light\" %\u003e \u003c% end %\u003e   step 13. 在首頁印出登入者資料\n1 2 3  \u003c% name  = current_user.present? ? current_user.email : '訪客' %\u003e \u003ch1\u003eWelcome, \u003c%= name %\u003e\u003c/h1\u003e   到這邊為止，就可以看到一個基本的登入頁面了。\n 參考資料:https://youtu.be/jd1gOhpETIA\n ","description":"","tags":null,"title":"Ruby on Rails devise","uri":"/posts/ruby_on_rails_devise/"},{"categories":null,"content":"候選人票選系統純手工打造 ．基本新增修改刪除介紹\n．使用vscode編輯\n．參考資料: 為你自己學Ruby On Rails\n00 開始之前 step 1. 使用指定Rails版本生成專案:\nrails _版本_ new 專案名\n% rails _6.1.5_ new hello_rails step 2. 進到該資料夾 cd hello_rails git版控初始化 git init\nstep 3. 第一次commit git add . git commit -m\"init commit\"\nstep 4. 確定環境正常運作 rails s 進到localhost:3000確認畫面\n01處理Route，新增(建立)路徑 step 1. 找到Route檔 confing -\u003e routes.rb (或是使用ctrl+p搜尋)\nstep 2. 做出候選人相關資源/路徑 在routes.rb檔案裡輸入\n1  resources :candidates   rails routes可查看路徑對照表 可看到做出的八條路徑，對應到七個action\ncandidates#index candidates#create candidates#new candidates#edit candidates#show candidates#update candidates#update candidates#destroy 若只想做出特定路徑，如index跟show，示範如下\n1  resources :candidates, only: [:index, :show]   step 3.新增controllers app -\u003e controllers 按右鍵新增檔案\ncandidates_controller.rb 接著，在檔案裡面輸入\n1 2 3 4 5  class CandidatesController \u003c ApplicationController def index end end   step 4. 新增view app -\u003e views 按右鍵新增資料夾\ncandidates 在candidates裡再新增檔案\nindex.html.erb 輸入\n1  \u003ch1\u003eHi\u003c/h1\u003e   這時，就可以在\nlocalhost:3000/candidates 看到剛剛輸入的Hi了\nstep3-step4手工打造的部分，可使用指令\n% rails g controller candidates 02 新增Model step 1.使用指令新增model\n要先想一下Candidate的Model要有哪些欄位及其對應的資料型態\nModel不等於資料庫/資料表，是一個抽象層的概念\n這個過程如果要純手工，會涉及到需手動建立migration檔來描述這個資料表要長什麼樣子，需要寫一些語法，對現階段的我們來說會有點吃力，建議直接使用指令\n% rails g model Candidate name:string party:string age:integer politics:text votes:integer 如果是文字型態(string)，可省略不寫\n% rails g model Candidate name party age:integer politics:text votes:integer 這個指令會幫你做兩件事\n 建立candidate這個model 會根據你給它的欄位，建位一個migration(主要目的)  慣例:如果model叫Candidate(大寫單數)，資料表migrate中的表格table就會是candidates(小寫複數)\nstep 2.描述檔具現化\n% rails db:migrate 會在 db 這個資料夾建立檔案 檔案名為:\ndevelopment.sqlite3 在rails預設使用的資料庫就是sqlite，它是一種檔案型的資料庫，效能不好，但簡單易用，以練習來說還算堪用，在我們這次開發過程中所有資料都會寫到這裡。\n在config/database.yml裡的adapter可以確認本次專案所使用的資料庫系統\n在不同的環境(開發、測試)，會存放在不同的資料庫\n例如 開發:\ndatabase:db/development.sqlite3 測試:\ndatabase:db/test.sqlite3 03 新增候選人表單 step 1. 確認表單路徑\n在\n% rails routes 找到\ncandidates/new step 2. 寫入連結 回到00章節中 step4 裡在candidates建立的index，在裡面寫入\n1  \u003ca href=\"/candidates/new\"\u003eAdd Candidate \u003c/a\u003e   就可以在\nlocalhost:3000/candidates 頁面看到我們設定的超連結了。但這時點下去這個超連結，應該會出現在錯誤訊息，因為我們還沒有做出相對應的action給它。\nstep 3.定義 new action 回到\ncandidate_controller.rb 定義 new action\n1 2  def new end   step 4. 做出 new 的view\n在views -\u003e candidates 新增檔案\nnew.html.erb 輸入\n1  \u003ch1\u003eAdd Candidate\u003c/h1\u003e   就可以在localhost:1313/candidates/new看到這行新增履歷的文字了\n03-1 手刻建立表單 step 1. 建立 form 表單，使用POST方法\n在 new.html.erb 檔裡寫入\n1 2 3 4  \u003cform action=\"candidates(要去什麼地方)\" method=\"POST(用什麼方式送)\"\u003e \u003cinput type=\"text\" name=\"abc\"\u003e \u003cinput type=\"submit\" value=\"go!\"\u003e \u003c/form\u003e   這邊要稍微記一下(或是可以參考路徑對照表)，在我們從candidates/new這邊，用POST方法往candidates送，那接著就會要找create這個action\ncandidate#create step 2.定義create action 回到\ncandidate_controller.rb 定義 create action\n1 2  def create end   step 3. 認識rails預設的保護機制\n為避免票務或其他相關設計的灌水問題，在使用form表單要往某個地方送的時候，rails會要求要有 authenticiy token。我們可以用以下的 ruby 方法\u003c%= form_authenticity_token %\u003e讓每次載入頁面時，會生出一段authenticity token。按下送出時這段token就會跟著表單一起送到 action。目的是要透過由我們發出去的 authenticity token 來確認用戶是從我們網站進來的，進而達到避免有心人士使用自己寫的程式來不停送出(票數)灌水。\n1  \u003cinput type=\"hidden\" name=\"authenticity_token\" value=\"\u003c%= form_authenticity_token %\u003e\"\u003e   03-2 使用form_for小幫手 在rails裡，有個叫form helper的小幫手，使用它來幫助我們建立表單。就不用像03-1過程這麼繁瑣。\nstep 1. 使用form_for form for 是為了某個model建立表單, 語法如下form_for(model) ，套用在我們這次的實作，因為Candidate是一個class，所以我們在後面加上.new，讓它變成一個model。並把它定義在candidates_controller.rb的new裡。並給它一個實體變數(@)，view才能拿的到。\n(之所以要把model定義在controller裡，是因為在 MVC 結構裡，view 的角色就是單純把東西印出來，不要做產生物件或邏輯運算之類的事，屬於被動角色)\n1 2 3  def new @candidate = Candidate.new end   回到candidates/new，把定義好的實體變數接在form_for裡\n\u003c%= form_for(@candidate) %\u003e form_for 發現後面接的是全新的model的時候，會幫你長出相對應的路徑、方法包含token全部寫完。\nstep 2. 搭配 ruby 的 程式碼區塊(Block) 搭配 ruby的程式碼區塊(Block)do end加上小幫手的.text_field方法來產生欄位，及.label方法來做出標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c%= form_for(@candidate) do |form| %\u003e \u003c%= form.label :name %\u003e \u003c%= form.text_field :name %\u003e \u003c%= form.label :party %\u003e \u003c%= form.text_field :party %\u003e \u003c%= form.label :age %\u003e \u003c%= form.text_field :age %\u003e \u003c%= form.label :politics %\u003e \u003c%= form.text_area :politics %\u003e \u003c%= form.submit %\u003e \u003c% end %\u003e   03-3 create action step 1. 得到parameters params 是一個方法會回傳 ActionController::Parameters 物件，在實務上會像一個 hash。所以我們可以透過params來取得parameters。\n在 03-2 把表單建立好，按下送出之後，在 log 中可以發現一包參數(parameters)，裡面包含token、欄位所填的資料 ，我們就可以透過params這個hash，使用candidate這個key來取得相對應的一包hash(value)\n1  params[:candidate]   丟給Candidate.new這個model。接著使用(@)實體變數建立物件，叫這個物件存檔(save)。如果成功，就把頁面導向候選人列表頁。 如果失敗，使用 render 這個方法，借 new 的頁面重新渲染。render :new\n1 2 3 4 5 6 7 8 9  def create @candidate = Candidate.new(params[:candidate]) if @candidate.save redirect_to '/cnadidates' else render :new end end    補充說明 1:hash是什麼? hash是由key、value所組成的資料，設計者只要根據Key值就可以取得相對應的資料。 如何建立hash？ 1.使用hash類別，new一個給他。\nuser = Hash.new\n2.使用大括號 user = { name: ‘Judy’, age:8 }\n  補充說明 2:製造巧合 在 new 及 create 取了一樣的實體變數名字，讓render :new 可以順利在空中抓取資料並透過form_for讓值擺放在相對應的欄位。\n def new @candidate = Candidate.new end def create @candidate = Candidate.new(candidate_params) end step 2. 清洗params 當我們試圖要把整包hash的資料透過 model 寫進資料庫的時候，model會發現這包網路上抓下的東西還沒清洗(過濾檢查)過(使用者可以很輕易的在頁面上編輯加欄位)。預設會擋下來。 使用 require 這個方法，抓取candidate並使用permit只允許部分欄位過來。\n1  params.require(:candidate).permit(:name, :party, :age, :politics)   接著，設定一個變數名稱給它，或是知道我們後面會很常再使用它，可以直接定義方法。再把它放進Candidate.new這個model。\n第一個方式如下:\n1 2 3 4 5 6 7 8 9 10 11  def create clean_params = params.require(:candidate).permit(:name, :party, :age, :politics) @candidate = Candidate.new(clean_params) if @candidate.save redirect_to '/cnadidates' else render :new end end   第二個方式，把它單獨定義一個方法，讓它可以被重複使用，因為不需被外部存取，可以加入 private 註記，變成私有方法。是一個比較好的作法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def create @candidate = Candidate.new(candidate_params) if @candidate.save redirect_to '/candidates' else render :new end end private def candidate_params params.require(:candidate).permit(:name, :party, :age, :politics) end   step 3. 確認存取的資料 在rails console或 rails c輸入\nCandidate.all 就可以印出目前Candidate這個表格裡的所有候選人\nstep 4. 使用者提示 flash flash 是快閃訊息的意思，只要印在畫面一次之後，就會消失。\nflash 本質上就是一個hash。key的慣例上會使用notice，後面再接上要給的訊息。寫的方式如下:\n1  flash[:notice] = \"Candidate created\"   接著，就在要印出這個flash的html頁面寫入\n1  \u003c%= flash[:notice]%\u003e   03-4 加入驗證 在 app -\u003e models 裡的 candidate.rb 檔，根據我們的驗證條件寫入 validates\n1 2 3  calss Candidate \u003c ApplicationRecord validates :name, present:true end   03-5 撈出候選人列表 我們已經順利把候選人寫入資料庫了，現在要把資料撈出來。在candidates_controller.rb這裡透過 Candidate 這個 model 的類別方法 all Candidate.all\n1 2 3  def index @candidates = Candidate.all end   並且在index.html.erb這個檔案裡用table，搭配使用ruby的迴圈each把候選人資料一筆一筆印出來\n03-6 link_to View-helper小幫手link_to\n1  \u003c%= link_to '要秀出來的字樣', '要去的位置'%\u003e   第二種寫法，使用路徑 Prefix 提供的名稱加上 _path\n1  \u003c%= link_to '要秀出來的字樣', new_cnadidate_path %\u003e   第二種寫法的優點  拼錯就會馬上噴錯 之後更改路徑名稱方便  所以盡量以第二種寫法為主。\n03-7 show action step 1. 重覆之前在controller定義action的方式定義show action。注意不要放在private底下。\n1 2  def show end   step 2. 做出view show.html.erb\nstep 3. 透過params拿id欄位回來用\n透過params拿id欄位回來，再透過modle的find_by方法找某候選人的資料\n1  @candidate = Candidate.find_by(id: params[:id])   step 4. 在show.html.erb做列表，把find_by 找到的資料印出來，會根據不同的id而有不同的結果。\nstep 5. 加上 if 判斷 如果候選人有資料，就印出來，反之，印出no record\n1 2 3 4 5 6 7  \u003c% if  @candidate %\u003e #印出資料 \u003c% else %\u003e \u003ch1\u003e No Record Found \u003c/h1\u003e \u003c% end %\u003e    補充說明\n\u003c%= %\u003e 與 \u003c% %\u003e\n兩者的差別在於需不需要於畫面輸出，有加=的會印出來。\n 03-8 沒有通過驗證的錯誤訊息 step 1.透過any?來詢問有沒有任何錯誤訊息\n.errors.any? 這時，對照03-3的save，存檔過程中要是沒有通過驗證，就可以在\n.errors.any? 得到true的結果\n再使用full_messages來得到錯誤訊息\n.errors.full_messages 一樣搭配.each的方法來逐個印出資訊\n1 2 3 4 5 6 7  \u003c% if  candidate.errors.any? %\u003e \u003cul\u003e \u003c% candidate.errors.full_messages.each  do |message| %\u003e \u003cli\u003e\u003c%= message %\u003e\u003c/li\u003e \u003c% end  %\u003e \u003c/ul\u003e    補充說明 可以透過.method的方法來確認有什麼method可以使用\n step2. 修正版面 因為驗證沒有過而render :new 回來後，版面會因為被多了一層div(field_with_errors)包裏而跑掉，我們要怎麼處理呢？\n來到 app -\u003e assets -\u003e stylesheets 資料夾裡按右鍵開一個檔案candidate.scss。這個資料夾裡的所有css檔案可以透過同個資料夾的application.css(打包描述檔)裡的這個描述\n*= require_tree . 打包回來。\n接著，就可以在candidate.scss編輯想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .field_with_errors{ display: inline-block; input[type=\"text\"]{ border-color: red; border-width: 1px; } label { color: red; } }   04 修改(edit) 一樣使用前面提到的link_to來寫。\nstep 1. 確認路徑\n/candidates/:id/edit step 2. 確認Prefix\nedit_candidate step 3. 在index.html.erb寫入\n1  \u003c%= link_to 'update', edit_candidate_path(candidate.id) %\u003e    補充說明\n若Prefix的欄位是空白的，則對應的是前一個欄位\n 04-1 edit action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def edit @candidate = Candidate.find_by(id: params[:id]) end   step 2. 做出view edit.html.erb\nstep 3. 做一個表單\n(可用new.html.erb的內容來套用)\nstep 4. PATCH / UPDATE 接下來在瀏覽器按下update後，可以在log裡看到form_for幫我們產出的其中一個input，有patch這個方法。\n1  \u003cinput type=\"hidden\" name=\"_method\" value=\"patch\"\u003e   這是因為目前瀏覽器還沒有支援到那麼多的方法(動詞)，所以rails用這個方式\"假裝\"patch(實際上是post)\n由路徑對照表可以看到，如果是用PATCH的方法對/cnadidates/:id這個路徑去送的話，會對應到candidates#update這個方法。\n 補充說明 1.\nrails會根據那個modle是不是全新的來判斷(猜測)form.submit是要使用create還是update\n全新的物件 -\u003e create 從資料庫撈出來的 -\u003e update\n  補充說明 2. (1) 用GET的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#show這個方法 (2) 用PUT的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#update這個方法\n(3) 用DELETE的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#destroy這個方法\n 04-2 update action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def update @candidate = Candidate.find_by(id: params[:id]) end   step 2. 類似 create action 的作法，並且失敗的話，借edit的頁面來渲染 1 2 3 4 5 6 7 8 9 10  def update @candidate = Candidate.find_by(id: params[:id]) if @candidate.update(candidate_params) flash[:notice] = \"Candidate updated!\" redirect_to '/cnadidates' else render :edit end end   05 刪除 step 1. 確認路徑\n/candidates/:id step 2. 確認Prefix\ncandidate (沒寫的話的，為同上)\nstep 3. 在index.html.erb寫入\n1  \u003c%= link_to 'delete', candidate_path(candidate.id) %\u003e   step 4. 做出跟update的區別 到目前為止，因為跟update一樣路徑都是在/candidates/:id 所以要在 link_to 裡加幾個參數，讓它不會往show送\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete' %\u003e   在檢視原始碼的時候，就會發現多出data-mathod=\"delete\" 如此，在頁面上按下delete的時候，就會對該路徑使用delete這個動詞，接著往/cnadidates/:id這個路徑去送，會找到candidates#destroy這個方法\n05-1 destroy action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3 4 5 6 7  def destroy @candidate = Candidate.find_by(id: params[:id]) @candidate.destroy flash[:notice] = \"Candidate deleted!\" redirect_to '/candidates' end   step 2. 防呆機制 在index.html.erb裡的link_to加上確認data: {confirm:\"\"}\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete', data: { confirm: 'are you sure?' } %\u003e   如此，便可以在刪除資料的時候，跳出確認視窗\n06 錯誤訊息 錯誤訊息的解答通常都在訊息裡\n錯誤訊息:missing a template 代表缺少MVC裡的V(view)，需要在view裡建相對應的 html 給它\n錯誤訊息:Migrations are pending 代表還有一個migrations還沒處理，執行rails db:migrate就可以解決\n錯誤訊息:UnKnown action 代表缺少某個action，需要在 controller 裡定義\n錯誤訊息:Routing Error. No route matches 找不到路徑(有可能是還沒建或是路徑打錯字)\n錯誤訊息:InvalidAuthenticity Token 無有效的驗證\n錯誤訊息:ForbiddenAttributesError 還沒清洗params(還不是白名單)\n rails設計哲學之一就是慣例優於設定\n ","description":"","tags":null,"title":"Ruby on Rails CRUD","uri":"/posts/ruby_on_rails_crud/"},{"categories":null,"content":"環境相關 ruby rvm list 查看電腦裡已經安裝哪些版本的Ruby:\n% rvm list ruby-2.7.2 [ arm64 ] =* ruby-2.7.5 [ arm64 ] =* 符號表示目前正在使用的版本(同時也是目前預設的 Ruby 版本)\nruby -v 查看目前 Ruby 的版本:\n% ruby -v ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [arm64-darwin21] $ rvm use 切換到其他版本的Ruby，例如想要切換到 2.7.2 版本:\n% rvm use 2.7.2 use可省略，例如要切換回2.7.5版本:\n% rvm 2.7.5 --default可設定預設Ruby版本:\n% rvm 2.7.5 --default 這樣之後每次開終端機視窗就會自動切換到 2.7.5 版\nrails gem list 查看電腦裡已經安裝哪些版本的Rails:\n% gem list rails (7.0.2.3, 7.0.2.2, 6.1.5) 或者使用gem list | grep rails\nrails -v 查看目前 Rails 的版本:\n% rails -v Rails 7.0.2.3 gem install rails 安裝最新版本Rails\ngem install rails -v 版本 安裝指定Rails版本:\n% gem install rails -v 6.1.5 rails _版本_ new 專案名使用指定Rails版本生成專案:\n% rails _6.1.5_ new hello_rails ","description":"","tags":null,"title":"Ruby on Rails Environments","uri":"/posts/ruby_on_rails_environments/"},{"categories":null,"content":"JavaScript是一種動態型別的程式語言(Dynamically Typed Language)，使用變量(Variable)及常量(Constant)來儲存數據。變數可以先宣告，再賦值，如:\n1 2  let age age = 20   常數則否，一定要同時進行，如:\n1  const myage = 18   所謂動態型別的程式語言是指，在運行期間才做數據類型檢查的語言。即動態類型語言編緝程式時，永遠不用給任何變量指定數據類型。 該語言會在第一次賦值給變量時，在內部將數據類型記錄下來\n並且充許在運行周期裡，儲存不同類型的數據。 例如:\n1 2  let message = 2; //數值 message = \"Hello World\" //轉換成字串   命名方式  可使用包含字母、數字、$、_ 首字符不能是數字 使用駝峰式命名法(如:myName)  八大資料型別    原始型別(Primitive Type) 物件型別( Object Type)     Boolean Object   Null    Undefined    Number    Bigint    String    Symbol     使用typeof 運算子可以幫助你判斷型別，其中函式（function）和陣列（array）、日期（date）皆為物件(Object)的一種，function 是可呼叫的物件，而 array 是結構較嚴謹的物件。\nFunction 函數  函數是一個行為(action) 一般只執行一個功能 參數可以配默認值參數 = \"默認值\" 可以返回或不返回值，返回值時需使用return  Async Await promise的出現，目標是為了解決callback hell的現象，而Async Await則是為了讓非同步執行變得更簡潔，更直觀\ncallback -\u003e promise -\u003e Async Await\n特點:\n 更貼近同步執行程式碼 概念是由promise基礎上演變 Async Await會返回promise object Await關鍵字只能在Async function裡使用，必須尾隨promise object 使用try catch語句捕捉Async Await出現的錯誤  ","description":"","tags":null,"title":"Beginner JavaScript Notes","uri":"/posts/java_script_notes/"},{"categories":null,"content":"陣列的 map、filter 跟 reduce 三個常用的方法介紹 在介紹這三個方法之前，先帶大家了解何謂\"callback function\"。\n引用 MDN 的說明如下:\n 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。它會在外部函式內調用，以完成某些事情。\n 簡單來說，就是一個程式執行完再去執行另一個程式，並且是在指定時機才觸發的。\n接著我們來看這三個方法在 W3Schools 中的說明\n map() Creates a new array with the result of calling a function for each array element\n  語法let new_array = arr.map(function callback( currentValue[, index[, array]]) {// return element for new_array}[, thisArg])\n  filter() Creates a new array with every element in an array that pass a test\n  語法var newArray = arr.filter(function callback(element[, index[, array]])[, thisArg])\n  reduce() Reduce the values of an array to a single value (going left-to-right)\n  語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n 根據語法我們可以發現這三個方法都是 callback function。\n翻成中文的意思大概如下:\nmap() 方法會建立一個新陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\nfilter() 方法會建立一個每一個元素經過指定運算判斷後回傳為真的新陣列。\nreduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。\nreduce 方法跟 map、filter 的差別是它會 return 一個值，而不是一個新陣列，這會連帶使 reduce 的語法結構跟邏輯與其他方法不太相同。\n看起來有點複雜，其實就是使用 callback 函式處理陣列中的每個元素，可傳入以下四個參數，我們再對照語法來看一次:\n 語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n  accumulator：累加器;經由個別 currentValue 加總的累計值 currentValue：Array 正在處理的元素 currentIndex(選擇性)：正在處理的元素索引 array(選擇性)：原始陣列  initialValue(選擇性)：初始值(預設值)，放在 function 的最後方，於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。\n","description":"","tags":null,"title":"filter, map and reduce in JS","uri":"/posts/java_script_method/"}]
