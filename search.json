[{"categories":null,"content":"在 rails 上使用 devise 套件 step 1. 在Gemfile加上\ngem 'devise' 或是在該目錄的終端機使用指令% bundle add 'devise'\nstep 2.\n% bundle install step3.\n% rails g devise:install 就會幫我們生成兩個在config下面的檔案\nconfig/initializers/devise.rb config/locales/devise.en.yml 接著在終端機的畫面同時顯示需要完成的指令:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  Some setup you must do manually if you haven't yet: 1. Ensure you have defined default url options in your environments files. Here is an example of default_url_options appropriate for a development environment in config/environments/development.rb: config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } In production, :host should be set to the actual host of your application. 2. Ensure you have defined root_url to *something* in your config/routes.rb. For example: root to: \"home#index\" 3. Ensure you have flash messages in app/views/layouts/application.html.erb. For example: \u003cp class=\"notice\"\u003e\u003c%= notice %\u003e\u003c/p\u003e \u003cp class=\"alert\"\u003e\u003c%= alert %\u003e\u003c/p\u003e 4. You can copy Devise views (for customization) to your app by running: rails g devise:views   一步一步的按照指令完成。\nstep 4.\n% rails g devise User 這個指令會幫我們生成一個migration檔 (db/migrate/20220423155313_devise_create_users.rb) 以及一個新的model檔(app/models/user.rb), 還有在routes.rb新增路徑divise_for :users\nstep 5. 更新資料庫\n% rails db:migrate step 6. 確認路徑\n% rails routes 找出user的路徑\n% rails routes | grep user 可以看到各路徑對照的行為，比如:\n1 2 3  new_user_session (sign_in) destroy_user_session (sign_out) new_user_registration (sign_up)   step 7. sign_up\n在終端機輸入rails s\n開啟http://localhost:3000/users/sign_up 就可以看到註冊頁面了\nstep 8. 清掉cookies\n註冊之後，因為目前的頁面還沒有做sign_out的連結，所以再輸入一次http://localhost:3000/users/sign_up會看到訊息:You are already signed in. 這時候的你，可以打開開發者工具中的Application的Cookies，把該檔案名稱對應的值刪掉，就可以清掉記錄進入到sign_up頁面\nstep 9. Bulma\n參考https://bulma.io/documentation/overview/ 下載Bulma，把樣式表插入app/views/laywout資料夾中的application.html.erb\n1  \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css\"\u003e   接著還要在同個檔案新增meta tag\n1  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e   step 10. 新增navbar 在 app/views 新增shared資料夾，並在裡面新增_navbar.html.erb檔，接著回到laywout的application.html.erb，在body的地方把剛剛的檔案渲染。\n1  \u003c%= render 'shared/navbar' %\u003e   step 11. 編輯navbar\n回到_navbar.html.erb檔，把BULMA的Basic Navbar樣式貼上去，再按照自己的需求編輯:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cnav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\"\u003e \u003cdiv class=\"navbar-brand\"\u003e \u003ca class=\"navbar-item\" href=\"https://bulma.io\"\u003e \u003cimg src=\"https://bulma.io/images/bulma-logo.png\" width=\"112\" height=\"28\"\u003e \u003c/a\u003e \u003ca role=\"button\" class=\"navbar-burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"navbarBasicExample\"\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e (過長省略，程式碼在: https://bulma.io/documentation/components/navbar/)   step 12. 新增sign_up、sign_out、sign_in連結在_navbar.html.erb檔\n1 2 3 4 5 6 7 8 9  \u003c% if  user_signed_in? %\u003e \u003c%= link_to 'Sign out', destroy_user_session_path, method: :delete, class: \"button is-primary\" %\u003e \u003c% else  %\u003e \u003c%= link_to 'Sign up', new_user_registration_path, class: \"button is-primary\" %\u003e \u003c%= link_to 'Log in', new_user_session_path, class: \"button is-light\" %\u003e \u003c% end %\u003e   step 13. 在首頁印出登入者資料\n1 2 3  \u003c% name  = current_user.present? ? current_user.email : '訪客' %\u003e \u003ch1\u003eWelcome, \u003c%= name %\u003e\u003c/h1\u003e   到這邊為止，就可以看到一個基本的登入頁面了。\n 參考資料:https://youtu.be/jd1gOhpETIA\n ","description":"","tags":null,"title":"Ruby on Rails devise","uri":"/posts/ruby_on_rails_divise/"},{"categories":null,"content":"候選人票選系統純手工打造 ．基本新增修改刪除介紹\n．使用vscode編輯\n．參考資料: 為你自己學Ruby On Rails\n00 開始之前 step 1. 使用指定Rails版本生成專案:\nrails _版本_ new 專案名\n% rails _6.1.5_ new hello_rails step 2. 進到該資料夾 cd hello_rails git版控初始化 git init\nstep 3. 第一次commit git add . git commit -m\"init commit\"\nstep 4. 確定環境正常運作 rails s 進到localhost:3000確認畫面\n01處理Route，新增(建立)路徑 step 1. 找到Route檔 confing -\u003e routes.rb (或是使用ctrl+p搜尋)\nstep 2. 做出候選人相關資源/路徑 在routes.rb檔案裡輸入\n1  resources :candidates   rails routes可查看路徑對照表 可看到做出的八條路徑，對應到七個action\ncandidates#index candidates#create candidates#new candidates#edit candidates#show candidates#update candidates#update candidates#destroy 若只想做出特定路徑，如index跟show，示範如下\n1  resources :candidates, only: [:index, :show]   step 3.新增controllers app -\u003e controllers 按右鍵新增檔案\ncandidates_controller.rb 接著，在檔案裡面輸入\n1 2 3 4 5  class CandidatesController \u003c ApplicationController def index end end   step 4. 新增view app -\u003e views 按右鍵新增資料夾\ncandidates 在candidates裡再新增檔案\nindex.html.erb 輸入\n1  \u003ch1\u003eHi\u003c/h1\u003e   這時，就可以在\nlocalhost:3000/candidates 看到剛剛輸入的Hi了\nstep3-step4手工打造的部分，可使用指令\n% rails g controller candidates 02 新增Model step 1.使用指令新增model\n要先想一下Candidate的Model要有哪些欄位及其對應的資料型態\nModel不等於資料庫/資料表，是一個抽象層的概念\n這個過程如果要純手工，會涉及到需手動建立migration檔來描述這個資料表要長什麼樣子，需要寫一些語法，對現階段的我們來說會有點吃力，建議直接使用指令\n% rails g model Candidate name:string party:string age:integer politics:text votes:integer 如果是文字型態(string)，可省略不寫\n% rails g model Candidate name party age:integer politics:text votes:integer 這個指令會幫你做兩件事\n 建立candidate這個model 會根據你給它的欄位，建位一個migration(主要目的)  慣例:如果model叫Candidate(大寫單數)，資料表migrate中的表格table就會是candidates(小寫複數)\nstep 2.描述檔具現化\n% rails db:migrate 會在 db 這個資料夾建立檔案 檔案名為:\ndevelopment.sqlite3 在rails預設使用的資料庫就是sqlite，它是一種檔案型的資料庫，效能不好，但簡單易用，以練習來說還算堪用，在我們這次開發過程中所有資料都會寫到這裡。\n在config/database.yml裡的adapter可以確認本次專案所使用的資料庫系統\n在不同的環境(開發、測試)，會存放在不同的資料庫\n例如 開發:\ndatabase:db/development.sqlite3 測試:\ndatabase:db/test.sqlite3 03 新增候選人表單 step 1. 確認表單路徑\n在\n% rails routes 找到\ncandidates/new step 2. 寫入連結 回到00章節中 step4 裡在candidates建立的index，在裡面寫入\n1  \u003ca href=\"/candidates/new\"\u003eAdd Candidate \u003c/a\u003e   就可以在\nlocalhost:3000/candidates 頁面看到我們設定的超連結了。但這時點下去這個超連結，應該會出現在錯誤訊息，因為我們還沒有做出相對應的action給它。\nstep 3.定義 new action 回到\ncandidate_controller.rb 定義 new action\n1 2  def new end   step 4. 做出 new 的view\n在views -\u003e candidates 新增檔案\nnew.html.erb 輸入\n1  \u003ch1\u003eAdd Candidate\u003c/h1\u003e   就可以在localhost:1313/candidates/new看到這行新增履歷的文字了\n03-1 手刻建立表單 step 1. 建立 form 表單，使用POST方法\n在 new.html.erb 檔裡寫入\n1 2 3 4  \u003cform action=\"candidates(要去什麼地方)\" method=\"POST(用什麼方式送)\"\u003e \u003cinput type=\"text\" name=\"abc\"\u003e \u003cinput type=\"submit\" value=\"go!\"\u003e \u003c/form\u003e   這邊要稍微記一下(或是可以參考路徑對照表)，在我們從candidates/new這邊，用POST方法往candidates送，那接著就會要找create這個action\ncandidate#create step 2.定義create action 回到\ncandidate_controller.rb 定義 create action\n1 2  def create end   step 3. 認識rails預設的保護機制\n為避免票務或其他相關設計的灌水問題，在使用form表單要往某個地方送的時候，rails會要求要有 authenticiy token。我們可以用以下的 ruby 方法\u003c%= form_authenticity_token %\u003e讓每次載入頁面時，會生出一段authenticity token。按下送出時這段token就會跟著表單一起送到 action。目的是要透過由我們發出去的 authenticity token 來確認用戶是從我們網站進來的，進而達到避免有心人士使用自己寫的程式來不停送出(票數)灌水。\n1  \u003cinput type=\"hidden\" name=\"authenticity_token\" value=\"\u003c%= form_authenticity_token %\u003e\"\u003e   03-2 使用form_for小幫手 在rails裡，有個叫form helper的小幫手，使用它來幫助我們建立表單。就不用像03-1過程這麼繁瑣。\nstep 1. 使用form_for form for 是為了某個model建立表單, 語法如下form_for(model) ，套用在我們這次的實作，因為Candidate是一個class，所以我們在後面加上.new，讓它變成一個model。並把它定義在candidates_controller.rb的new裡。並給它一個實體變數(@)，view才能拿的到。\n(之所以要把model定義在controller裡，是因為在 MVC 結構裡，view 的角色就是單純把東西印出來，不要做產生物件或邏輯運算之類的事，屬於被動角色)\n1 2 3  def new @candidate = Candidate.new end   回到candidates/new，把定義好的實體變數接在form_for裡\n\u003c%= form_for(@candidate) %\u003e form_for 發現後面接的是全新的model的時候，會幫你長出相對應的路徑、方法包含token全部寫完。\nstep 2. 搭配 ruby 的 程式碼區塊(Block) 搭配 ruby的程式碼區塊(Block)do end加上小幫手的.text_field方法來產生欄位，及.label方法來做出標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c%= form_for(@candidate) do |form| %\u003e \u003c%= form.label :name %\u003e \u003c%= form.text_field :name %\u003e \u003c%= form.label :party %\u003e \u003c%= form.text_field :party %\u003e \u003c%= form.label :age %\u003e \u003c%= form.text_field :age %\u003e \u003c%= form.label :politics %\u003e \u003c%= form.text_area :politics %\u003e \u003c%= form.submit %\u003e \u003c% end %\u003e   03-3 create action step 1. 得到parameters params 是一個方法會回傳 ActionController::Parameters 物件，在實務上會像一個 hash。所以我們可以透過params來取得parameters。\n在 03-2 把表單建立好，按下送出之後，在 log 中可以發現一包參數(parameters)，裡面包含token、欄位所填的資料 ，我們就可以透過params這個hash，使用candidate這個key來取得相對應的一包hash(value)\n1  params[:candidate]   丟給Candidate.new這個model。接著使用(@)實體變數建立物件，叫這個物件存檔(save)。如果成功，就把頁面導向候選人列表頁。 如果失敗，使用 render 這個方法，借 new 的頁面重新渲染。render :new\n1 2 3 4 5 6 7 8 9  def create @candidate = Candidate.new(params[:candidate]) if @candidate.save redirect_to '/cnadidates' else render :new end end    補充說明 1:hash是什麼? hash是由key、value所組成的資料，設計者只要根據Key值就可以取得相對應的資料。 如何建立hash？ 1.使用hash類別，new一個給他。\nuser = Hash.new\n2.使用大括號 user = { name: ‘Judy’, age:8 }\n  補充說明 2:製造巧合 在 new 及 create 取了一樣的實體變數名字，讓render :new 可以順利在空中抓取資料並透過form_for讓值擺放在相對應的欄位。\n def new @candidate = Candidate.new end def create @candidate = Candidate.new(candidate_params) end step 2. 清洗params 當我們試圖要把整包hash的資料透過 model 寫進資料庫的時候，model會發現這包網路上抓下的東西還沒清洗(過濾檢查)過(使用者可以很輕易的在頁面上編輯加欄位)。預設會擋下來。 使用 require 這個方法，抓取candidate並使用permit只允許部分欄位過來。\n1  params.require(:candidate).permit(:name, :party, :age, :politics)   接著，設定一個變數名稱給它，或是知道我們後面會很常再使用它，可以直接定義方法。再把它放進Candidate.new這個model。\n第一個方式如下:\n1 2 3 4 5 6 7 8 9 10 11  def create clean_params = params.require(:candidate).permit(:name, :party, :age, :politics) @candidate = Candidate.new(clean_params) if @candidate.save redirect_to '/cnadidates' else render :new end end   第二個方式，把它單獨定義一個方法，讓它可以被重複使用，因為不需被外部存取，可以加入 private 註記，變成私有方法。是一個比較好的作法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def create @candidate = Candidate.new(candidate_params) if @candidate.save redirect_to '/candidates' else render :new end end private def candidate_params params.require(:candidate).permit(:name, :party, :age, :politics) end   step 3. 確認存取的資料 在rails console或 rails c輸入\nCandidate.all 就可以印出目前Candidate這個表格裡的所有候選人\nstep 4. 使用者提示 flash flash 是快閃訊息的意思，只要印在畫面一次之後，就會消失。\nflash 本質上就是一個hash。key的慣例上會使用notice，後面再接上要給的訊息。寫的方式如下:\n1  flash[:notice] = \"Candidate created\"   接著，就在要印出這個flash的html頁面寫入\n1  \u003c%= flash[:notice]%\u003e   03-4 加入驗證 在 app -\u003e models 裡的 candidate.rb 檔，根據我們的驗證條件寫入 validates\n1 2 3  calss Candidate \u003c ApplicationRecord validates :name, present:true end   03-5 撈出候選人列表 我們已經順利把候選人寫入資料庫了，現在要把資料撈出來。在candidates_controller.rb這裡透過 Candidate 這個 model 的類別方法 all Candidate.all\n1 2 3  def index @candidates = Candidate.all end   並且在index.html.erb這個檔案裡用table，搭配使用ruby的迴圈each把候選人資料一筆一筆印出來\n03-6 link_to View-helper小幫手link_to\n1  \u003c%= link_to '要秀出來的字樣', '要去的位置'%\u003e   第二種寫法，使用路徑 Prefix 提供的名稱加上 _path\n1  \u003c%= link_to '要秀出來的字樣', new_cnadidate_path %\u003e   第二種寫法的優點  拼錯就會馬上噴錯 之後更改路徑名稱方便  所以盡量以第二種寫法為主。\n03-7 show action step 1. 重覆之前在controller定義action的方式定義show action。注意不要放在private底下。\n1 2  def show end   step 2. 做出view show.html.erb\nstep 3. 透過params拿id欄位回來用\n透過params拿id欄位回來，再透過modle的find_by方法找某候選人的資料\n1  @candidate = Candidate.find_by(id: params[:id])   step 4. 在show.html.erb做列表，把find_by 找到的資料印出來，會根據不同的id而有不同的結果。\nstep 5. 加上 if 判斷 如果候選人有資料，就印出來，反之，印出no record\n1 2 3 4 5 6 7  \u003c% if  @candidate %\u003e #印出資料 \u003c% else %\u003e \u003ch1\u003e No Record Found \u003c/h1\u003e \u003c% end %\u003e    補充說明\n\u003c%= %\u003e 與 \u003c% %\u003e\n兩者的差別在於需不需要於畫面輸出，有加=的會印出來。\n 03-8 沒有通過驗證的錯誤訊息 step 1.透過any?來詢問有沒有任何錯誤訊息\n.errors.any? 這時，對照03-3的save，存檔過程中要是沒有通過驗證，就可以在\n.errors.any? 得到true的結果\n再使用full_messages來得到錯誤訊息\n.errors.full_messages 一樣搭配.each的方法來逐個印出資訊\n1 2 3 4 5 6 7  \u003c% if  candidate.errors.any? %\u003e \u003cul\u003e \u003c% candidate.errors.full_messages.each  do |message| %\u003e \u003cli\u003e\u003c%= message %\u003e\u003c/li\u003e \u003c% end  %\u003e \u003c/ul\u003e    補充說明 可以透過.method的方法來確認有什麼method可以使用\n step2. 修正版面 因為驗證沒有過而render :new 回來後，版面會因為被多了一層div(field_with_errors)包裏而跑掉，我們要怎麼處理呢？\n來到 app -\u003e assets -\u003e stylesheets 資料夾裡按右鍵開一個檔案candidate.scss。這個資料夾裡的所有css檔案可以透過同個資料夾的application.css(打包描述檔)裡的這個描述\n*= require_tree . 打包回來。\n接著，就可以在candidate.scss編輯想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .field_with_errors{ display: inline-block; input[type=\"text\"]{ border-color: red; border-width: 1px; } label { color: red; } }   04 修改(edit) 一樣使用前面提到的link_to來寫。\nstep 1. 確認路徑\n/candidates/:id/edit step 2. 確認Prefix\nedit_candidate step 3. 在index.html.erb寫入\n1  \u003c%= link_to 'update', edit_candidate_path(candidate.id) %\u003e    補充說明\n若Prefix的欄位是空白的，則對應的是前一個欄位\n 04-1 edit action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def edit @candidate = Candidate.find_by(id: params[:id]) end   step 2. 做出view edit.html.erb\nstep 3. 做一個表單\n(可用new.html.erb的內容來套用)\nstep 4. PATCH / UPDATE 接下來在瀏覽器按下update後，可以在log裡看到form_for幫我們產出的其中一個input，有patch這個方法。\n1  \u003cinput type=\"hidden\" name=\"_method\" value=\"patch\"\u003e   這是因為目前瀏覽器還沒有支援到那麼多的方法(動詞)，所以rails用這個方式\"假裝\"patch(實際上是post)\n由路徑對照表可以看到，如果是用PATCH的方法對/cnadidates/:id這個路徑去送的話，會對應到candidates#update這個方法。\n 補充說明 1.\nrails會根據那個modle是不是全新的來判斷(猜測)form.submit是要使用create還是update\n全新的物件 -\u003e create 從資料庫撈出來的 -\u003e update\n  補充說明 2. (1) 用GET的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#show這個方法 (2) 用PUT的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#update這個方法\n(3) 用DELETE的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#destroy這個方法\n 04-2 update action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def update @candidate = Candidate.find_by(id: params[:id]) end   step 2. 類似 create action 的作法，並且失敗的話，借edit的頁面來渲染 1 2 3 4 5 6 7 8 9 10  def update @candidate = Candidate.find_by(id: params[:id]) if @candidate.update(candidate_params) flash[:notice] = \"Candidate updated!\" redirect_to '/cnadidates' else render :edit end end   05 刪除 step 1. 確認路徑\n/candidates/:id step 2. 確認Prefix\ncandidate (沒寫的話的，為同上)\nstep 3. 在index.html.erb寫入\n1  \u003c%= link_to 'delete', candidate_path(candidate.id) %\u003e   step 4. 做出跟update的區別 到目前為止，因為跟update一樣路徑都是在/candidates/:id 所以要在 link_to 裡加幾個參數，讓它不會往show送\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete' %\u003e   在檢視原始碼的時候，就會發現多出data-mathod=\"delete\" 如此，在頁面上按下delete的時候，就會對該路徑使用delete這個動詞，接著往/cnadidates/:id這個路徑去送，會找到candidates#destroy這個方法\n05-1 destroy action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3 4 5 6 7  def destroy @candidate = Candidate.find_by(id: params[:id]) @candidate.destroy flash[:notice] = \"Candidate deleted!\" redirect_to '/candidates' end   step 2. 防呆機制 在index.html.erb裡的link_to加上確認data: {confirm:\"\"}\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete', data: { confirm: 'are you sure?' } %\u003e   如此，便可以在刪除資料的時候，跳出確認視窗\n06 錯誤訊息 錯誤訊息的解答通常都在訊息裡\n錯誤訊息:missing a template 代表缺少MVC裡的V(view)，需要在view裡建相對應的 html 給它\n錯誤訊息:Migrations are pending 代表還有一個migrations還沒處理，執行rails db:migrate就可以解決\n錯誤訊息:UnKnown action 代表缺少某個action，需要在 controller 裡定義\n錯誤訊息:Routing Error. No route matches 找不到路徑(有可能是還沒建或是路徑打錯字)\n錯誤訊息:InvalidAuthenticity Token 無有效的驗證\n錯誤訊息:ForbiddenAttributesError 還沒清洗params(還不是白名單)\n rails設計哲學之一就是慣例優於設定\n ","description":"","tags":null,"title":"Ruby on Rails CRUD","uri":"/posts/ruby_on_rails_curd/"},{"categories":null,"content":"環境相關 ruby rvm list 查看電腦裡已經安裝哪些版本的Ruby:\n% rvm list ruby-2.7.2 [ arm64 ] =* ruby-2.7.5 [ arm64 ] =* 符號表示目前正在使用的版本(同時也是目前預設的 Ruby 版本)\nruby -v 查看目前 Ruby 的版本:\n% ruby -v ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [arm64-darwin21] $ rvm use 切換到其他版本的Ruby，例如想要切換到 2.7.2 版本:\n% rvm use 2.7.2 use可省略，例如要切換回2.7.5版本:\n% rvm 2.7.5 --default可設定預設Ruby版本:\n% rvm 2.7.5 --default 這樣之後每次開終端機視窗就會自動切換到 2.7.5 版\nrails gem list 查看電腦裡已經安裝哪些版本的Rails:\n% gem list rails (7.0.2.3, 7.0.2.2, 6.1.5) 或者使用gem list | grep rails\nrails -v 查看目前 Rails 的版本:\n% rails -v Rails 7.0.2.3 gem install rails 安裝最新版本Rails\ngem install rails -v 版本 安裝指定Rails版本:\n% gem install rails -v 6.1.5 rails _版本_ new 專案名使用指定Rails版本生成專案:\n% rails _6.1.5_ new hello_rails ","description":"","tags":null,"title":"Ruby on Rails Environments","uri":"/posts/ruby_on_rails_environments/"},{"categories":null,"content":"JavaScript是一種動態型別的程式語言(Dynamically Typed Language)，使用變量(Variable)及常量(Constant)來儲存數據。變數可以先宣告，再賦值，如:\n1 2  let age age = 20   常數則否，一定要同時進行，如:\n1  const myage = 18   所謂動態型別的程式語言是指，在運行期間才做數據類型檢查的語言。即動態類型語言編緝程式時，永遠不用給任何變量指定數據類型。 該語言會在第一次賦值給變量時，在內部將數據類型記錄下來\n並且充許在運行周期裡，儲存不同類型的數據。 例如:\n1 2  let message = 2; //數值 message = \"Hello World\" //轉換成字串   命名方式  可使用包含字母、數字、$、_ 首字符不能是數字 使用駝峰式命名法(如:myName)  八大數據類型 table bigint boolean undefined object number string null symbol\n","description":"","tags":null,"title":"Beginner JavaScript Notes","uri":"/posts/java_script_notes/"},{"categories":null,"content":"陣列的 map、filter 跟 reduce 三個常用的方法介紹 在介紹這三個方法之前，先帶大家了解何謂\"callback function\"。\n引用 MDN 的說明如下:\n 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。它會在外部函式內調用，以完成某些事情。\n 簡單來說，就是一個程式執行完再去執行另一個程式，並且是在指定時機才觸發的。\n接著我們來看這三個方法在 W3Schools 中的說明\n map() Creates a new array with the result of calling a function for each array element\n  語法let new_array = arr.map(function callback( currentValue[, index[, array]]) {// return element for new_array}[, thisArg])\n  filter() Creates a new array with every element in an array that pass a test\n  語法var newArray = arr.filter(function callback(element[, index[, array]])[, thisArg])\n  reduce() Reduce the values of an array to a single value (going left-to-right)\n  語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n 根據語法我們可以發現這三個方法都是 callback function。\n翻成中文的意思大概如下:\nmap() 方法會建立一個新陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\nfilter() 方法會建立一個每一個元素經過指定運算判斷後回傳為真的新陣列。\nreduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。\nreduce 方法跟 map、filter 的差別是它會 return 一個值，而不是一個新陣列，這會連帶使 reduce 的語法結構跟邏輯與其他方法不太相同。\n看起來有點複雜，其實就是使用 callback 函式處理陣列中的每個元素，可傳入以下四個參數，我們再對照語法來看一次:\n 語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n  accumulator：累加器;經由個別 currentValue 加總的累計值 currentValue：Array 正在處理的元素 currentIndex(選擇性)：正在處理的元素索引 array(選擇性)：原始陣列  initialValue(選擇性)：初始值(預設值)，放在 function 的最後方，於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。\n","description":"","tags":null,"title":"filter, map and reduce in JS","uri":"/posts/java_script_method/"}]
