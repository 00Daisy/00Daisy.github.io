[{"categories":null,"content":"What is Abstraction Abstraction refers to the process of simplifying a complex system, data, or computation into a more understandable and manageable model or concept. Through abstraction, programmers can hide unnecessary details in a system and provide a concise and easy-to-use interface for other program modules or users.\nFor example, when designing a library system, we can abstract the concept of “book” without considering the specific details such as size, weight, and shape. This simplifies the system design and provides a clearer interface for users to manage library resources.\nAbstraction is a crucial concept in programming because it can improve code readability, reusability, and maintainability. It is also a core principle in object-oriented programming, where data and operations are separated, and an abstraction layer is provided to hide implementation details.\nThere are several methods to achieve abstraction:\n  Classes: Using classes can encapsulate related data and operations to form an abstract class. Users only need to know the interface and usage of this class without understanding the specific implementation details.\n  Interfaces: Interfaces define a collection of operations that are exposed to the outside. Users only need to know the names and parameters of these operations without understanding the specific implementation details. Interfaces can allow different classes to implement the same operation, achieving code reuse.\n  Abstract classes: Abstract classes are classes that cannot be instantiated. They define an interface and some concrete implementations. Users can use the interface of this abstract class without understanding the specific implementation details.\n  Delegation: Delegation is a mechanism that delegates an operation to another object for execution. This can hide implementation details and only expose necessary interfaces.\n  Generics: Generics is a technique that allows programmers to write generic code. Using generics, code that can handle different types of data can be written, achieving code reuse and abstraction.\n  These are some methods to achieve abstraction, and programmers can choose the most suitable method according to their actual needs.\nAbstraction vs Encapsulation Abstraction and Encapsulation are two different but related concepts in Object-Oriented Programming.\nAbstraction refers to the process of representing complex real-world objects as simpler models, focusing only on the key features and functionalities of the object without considering its implementation details. This helps simplify the system and makes it easier to understand and manage.\nEncapsulation, on the other hand, refers to the technique of hiding the internal details of an object and only exposing the public interface. It groups related properties and methods into a class, and separates them from other classes’ properties and methods. Encapsulation prevents external code from accessing and modifying an object’s properties and methods improperly, improving code security and reliability.\nIn essence, Abstraction focuses on the essence of an object, while Encapsulation focuses on hiding the external interface and internal implementation details of the object. Abstraction and Encapsulation are two fundamental concepts in OOP, and they are often used together.\nExample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Animal attr_reader :name, :species def initialize(name, species) @name = name @species = species end def speak raise NotImplementedError, \"Subclass must implement abstract method\" end end class Cat \u003c Animal def speak \"Meow!\" end end class Dog \u003c Animal def speak \"Woof!\" end end animal = Animal.new(\"ann\", \"pig\") cat = Cat.new(\"Kitty\", \"Felis catus\") dog = Dog.new(\"Rex\", \"Canis lupus familiaris\") puts \"#{cat.name}the #{cat.species}says #{cat.speak}\" # Kitty the Felis catus says Meow! puts \"#{dog.name}the #{dog.species}says #{dog.speak}\" # Rex the Canis lupus familiaris says Woof! puts \"#{animal.name}the #{animal.species}says #{animal.speak}\" # Subclass must implement abstract method (NotImplementedError)   In the above code, the Animal class is an abstract class because it defines a speak method but does not implement it. This is because different animals have different sounds, and we want to implement this method in subclasses. The Cat and Dog classes inherit from the Animal class and implement the speak method. In this example, the Animal class abstracts a real-world concept - animals, while the Cat and Dog classes are concrete implementations.\nThe Animal class encapsulates its two properties - name and species. These properties are defined as instance variables and can only be accessed or modified through defined accessor methods (getter/setter). This prevents external code from directly accessing or modifying the object.\nattr_reader, attr_writer, and attr_accessor can be considered as one way of implementing encapsulation in Ruby. These methods are built-in shortcuts in Ruby that allow developers to easily define getter and setter methods for instance variables, while preventing direct access or modification of instance variables from external code, thus protecting the object’s internal state.\nThe actual effect of these methods is to define a method that allows access to an object’s internal state from outside the object without directly accessing the instance variable of the object. This hides the instance variable and provides a more concise syntax. Encapsulation is one of the important means to achieve high cohesion and low coupling in well-designed object-oriented programs, which can improve the maintainability and readability of the code.\n抽象化是什麼 抽象化（abstraction）是一個將複雜的系統、資料或運算，簡化成一個更易理解、更易處理的模型或概念的過程。透過抽象化，程式設計師可以將系統中不必要的細節隱藏起來，並提供一個簡潔、易於使用的介面，以供其他程式模組或使用者使用。\n舉例來說，當設計一個圖書館系統時，我們可以抽象化出“圖書”這個概念，而不必考慮圖書的具體細節，如大小、重量、形狀等。這樣一來，我們就可以簡化系統的設計，並提供一個更清晰的介面，讓使用者可以更容易地管理圖書館資源。\n抽象化在程式設計中是一個非常重要的概念，因為它可以提高代碼的可讀性、可重用性和可維護性。同時，它也是面向對象程式設計中的核心原則之一，即將資料和操作分離，並提供一個抽象層，以隱藏實現細節。\n  類別：使用類別可以將相關的資料和操作封裝起來，形成一個抽象的類別。使用者只需要知道這個類別的介面和使用方法，而不必了解具體實現的細節。\n  介面：介面定義了一個對外暴露的操作集合，使用者只需要知道這些操作的名稱和參數，而不必了解具體實現的細節。介面可以讓不同的類別實現相同的操作，從而達到代碼的重用。\n  抽象類別：抽象類別是一個不能被實例化的類別，它定義了一個介面和一些具體實現。使用者可以使用這個抽象類別的介面，而不必了解具體實現的細節。\n  委託：委託是一個將一個操作轉交給另一個對象來執行的機制。這樣可以將實現細節隱藏起來，只暴露必要的介面。\n  泛型：泛型是一種可以讓程式設計師編寫出具有一般性的代碼的技術。使用泛型，可以編寫出可以處理不同類型資料的代碼，從而達到代碼的重用和抽象化。\n  以上是實現抽象化的一些方法，程式設計師可以根據實際需求選擇最適合的方法。\n抽象化 vs 封裝 抽象化（Abstraction）和封裝（Encapsulation）是面向對象編程中兩個不同但相關的概念。\n抽象化是指將複雜的現實世界對象抽象成更簡單的模型，僅關注對象的關鍵特徵和功能，而不考慮其實現細節。這樣做有助於簡化系統，使其更容易理解和管理。\n封裝是指隱藏對象的內部細節，只暴露對外的接口。將相關的屬性和方法組成一個類，並將其與其他類的屬性和方法分離開來。封裝可以防止外部代碼不當訪問和修改對象的屬性和方法，提高代碼的安全性和可靠性。\n簡單來說，抽象化關注對象的本質，而封裝關注對象的外部可見接口和內部實現細節的隱藏。抽象化和封裝是OOP中兩個基本的概念，它們通常是一起使用的。\n範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Animal attr_reader :name, :species def initialize(name, species) @name = name @species = species end def speak raise NotImplementedError, \"Subclass must implement abstract method\" end end class Cat \u003c Animal def speak \"Meow!\" end end class Dog \u003c Animal def speak \"Woof!\" end end animal = Animal.new(\"ann\", \"pig\") cat = Cat.new(\"Kitty\", \"Felis catus\") dog = Dog.new(\"Rex\", \"Canis lupus familiaris\") puts \"#{cat.name}the #{cat.species}says #{cat.speak}\" # Kitty the Felis catus says Meow! puts \"#{dog.name}the #{dog.species}says #{dog.speak}\" # Rex the Canis lupus familiaris says Woof! puts \"#{animal.name}the #{animal.species}says #{animal.speak}\" # Subclass must implement abstract method (NotImplementedError)   在上面的代碼中，Animal 類是一個抽象類，因為它定義了一個 speak 方法，但沒有實現它。這是因為不同的動物有不同的叫聲，而我們希望在子類中實現這個方法。Cat 和 Dog 類繼承了 Animal 類，實現了 speak 方法。在這個例子中，Animal 類抽象了一個現實世界的概念 - 動物，而 Cat 和 Dog 類則是具體的實現。\n在 Ruby 中，可以使用實例變量（Instance Variable）和屬性訪問器（Accessor）來實現封裝\nAnimal 類封裝了其兩個屬性 - name 和 species。這些屬性被定義為實例變量，並且只能通過定義的屬性訪問器方法（getter/setter）來訪問或修改。\nattr_reader、attr_writer 和 attr_accessor 可以算是 Ruby 中實現封裝的方法之一。這些方法都是 Ruby 內置的快捷方式，可以讓開發者輕鬆地定義實例變數的 getter 和 setter 方法，同時避免外部程式碼直接訪問或設定實例變數，保護了物件的內部狀態。\n這些方法的實際效果是定義了一個方法，使得可以從物件外部存取對象的內部狀態，而不需要直接訪問物件的實例變數。這樣可以隱藏實例變數，同時提供更簡潔的語法。在設計良好的物件導向程式中，封裝是實現高內聚低耦合的重要手段之一，能夠提高代碼的可維護性和可讀性。\n","description":"","tags":null,"title":"Abstraction","uri":"/posts/abstraction/"},{"categories":null,"content":"What is Object Oriented Programming Object Oriented Programming (OOP) is a software development methodology that models real-world objects and builds software based on how these objects interact with each other.\nIn OOP, objects in software are made up of data properties and methods that operate on that data. These objects can be seen as entities within the software, and they work together to accomplish specific tasks. For example, a bank account object might have properties such as balance and account number, and methods such as deposit and withdraw.\nThe fundamental concepts of OOP are “classes” and “objects”. Classes describe the blueprint or template for objects, and objects are instances created from these classes. In OOP, objects can be made more flexible through concepts such as inheritance and polymorphism, making the code more organized, reusable, and easier to maintain.\nOOP provides a way to break down complex programs into smaller, more manageable parts. By breaking a program into classes and objects, we can create code that is easier to understand, modify, and maintain. Additionally, OOP can increase the reusability of software, as developers can use existing objects to develop new functionality. It is widely used in modern programming languages such as Java, Python, and Ruby, among others.\nThe four core concepts of OOP are:\n  Abstraction: Abstraction is the process of representing complex real-world objects as simpler classes or interfaces, which hides the implementation details and only exposes the object’s functionality and properties. By abstracting objects, the programmer can simplify the system’s complexity, making it easier to understand and manage.\n  Encapsulation: Encapsulation is the technique of hiding the internal details of an object and only exposing the public interface. It groups related properties and methods into a class, and separates them from other classes’ properties and methods. Encapsulation prevents external code from accessing and modifying an object’s properties and methods improperly, improving code security and reliability.\n  Inheritance: Inheritance is the mechanism that enables a new object to acquire properties and methods from an existing object. It promotes code reuse and structuring. Inheritance allows the programmer to create new code based on existing code, saving development time and improving code reusability.\n  Polymorphism: Polymorphism refers to the ability of objects to take on multiple forms, where the same operation can behave differently on different objects. Polymorphism allows for flexibility and extensibility, improving code readability, maintainability, and reusability. Polymorphism can be achieved through method overloading, method overriding, and interfaces.\n  These concepts are interrelated and are usually used together to implement complex code. OOP can help programmers write code that is easy to understand, reuse, and maintain, while improving the quality and productivity of the code.\nObject Oriented Programming (OOP) 是一種軟體開發的方法，它將現實世界中的物件模型化，以物件之間的互動方式來建立軟體。\n在 OOP 中，軟體中的物件由資料屬性和操作資料的方法所構成。這些物件可以被看做軟體中的實體，它們能夠合作來完成特定的任務。例如，一個銀行帳戶物件可以有屬性如餘額、帳戶號碼等，而方法則可以是存款、提款等。\nOOP 的基本概念是「類別」和「物件」。類別是用來描述物件的藍圖或模板，而物件是透過這些類別來建立的實體。在 OOP 中，物件能夠透過繼承和多型等概念來增加彈性，讓程式碼更有組織性、可重複使用性和易於維護性。\nOOP 提供了一種將複雜程式拆解成更小、更易管理的部分的方式。透過將程式拆解成類別和物件，我們可以創建出更容易理解、修改和維護的程式碼。此外，物件導向程式設計也可以增加軟體的可重用性，因為開發者可以使用現有的物件來開發新的功能。它廣泛地應用於現代程式語言，如 Java、Python 和 Ruby 等。\nOOP的核心概念包括以下四個：\n  Abstraction（抽象化）：抽象化是將具體事物抽象成一個類別或介面，使程式設計師可以隱藏實現細節，只關注物件的功能和特性。透過抽象化，程式設計師可以簡化系統的複雜性，使其易於理解和管理。\n  Encapsulation（封裝）：封裝是一種隱藏物件細節的技術。它將相關的屬性和方法組合起來形成一個類別，同時將其與其他類別的屬性和方法分開。封裝可以防止外部代碼不當地訪問和修改物件的屬性和方法，從而提高代碼的安全性和可靠性。\n  Inheritance（繼承）：繼承是指一個物件可以獲得另一個物件的屬性和方法，從而可以重複利用代碼並實現代碼的結構化。透過繼承，程式設計師可以建立基於現有代碼的新代碼，從而節省開發時間並提高代碼的可重複利用性。\n  Polymorphism（多態性）：多態性是指相同的操作可以作用於不同的物件上，產生不同的行為。它可以實現代碼的靈活性和擴展性，從而提高代碼的可讀性、可維護性和可重用性。多態性是OOP中最重要的概念之一，它可以通過方法重載、方法重寫和介面實現。\n  透過這些核心概念的運用，程式設計師可以寫出易讀、易維護、可重複利用、彈性及可擴充的程式。\nExample 1 下面是一個簡單的例子，展示如何使用 Ruby 的物件導向程式設計來建立一個簡單的人物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Person attr_accessor :name, :age def say_hello puts \"Hello, my name is #{@name}and I'm #{@age}years old.\" end end # Create a new Person object my_person = Person.new # Set the name and age attributes my_person.name = \"Alice\" my_person.age = 30 my_person.say_hello #\"Hello, my name is Alice and I'm 30 years old.\"   In this example, the Person class defines two attributes using the attr_accessor method: name and age. This automatically creates getter and setter methods for the attributes, so we can set their values using person.name = “Alice” and person.age = 30.\nThe say_hello method uses the name and age attributes to output a message introducing the person. We can call this method on the Person object by using person.say_hello.\nUsing attr_accessor instead of an initialize method can simplify the code for simple cases like this where we just need to define a few attributes for an object.\n這個程式碼定義了一個 Person 類別，該類別具有 name 和 age 兩個屬性以及一個 say_hello 方法。使用 attr_accessor 來定義存取器方法，用於設置和獲取實例變數。在 say_hello 方法中，會顯示一條簡單的消息，顯示人的名字和年齡。\n在這個例子中，我們創建一個名為 my_person 的 Person 物件，並設置其 name 和 age 屬性，最後呼叫它的 say_hello 方法來顯示人的資訊。\n使用 attr_accessor 而不是 initialize 方法可以簡化像這樣的簡單情況的代碼，我們只需要為一個對象定義一些屬性。\nExample 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Person attr_accessor :name, :age def initialize(name, age) @name = name @age = age end def introduce puts \"Hi, my name is #{@name}and I'm #{@age}years old.\" end end person1 = Person.new(\"John\", 30) person2 = Person.new(\"Jane\", 25) person1.introduce person2.introduce   In this example, the Person class has an initialize method that takes two parameters, name and age. These parameters are used to set the instance variables @name and @age, respectively. The attr_accessor method is used to define getter and setter methods for these instance variables.\nThe introduce method is used to print out a message introducing the person by name and age. Two instances of the Person class are created with the new method, and the introduce method is called on each of them to introduce them.\nExample 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Game def initialize @number = rand(1..100) @guesses = 0 @game_over = false end def play puts \"Let's play a guessing game!\" until @game_over guess = get_guess check_guess(guess) end end private def get_guess puts \"Enter a number between 1 and 100:\" gets.chomp.to_i end def check_guess(guess) @guesses += 1 if guess == @number puts \"Congratulations, you guessed the number in #{@guesses}tries!\" @game_over = true elsif guess \u003c @number puts \"Sorry, that's too low. Guess again.\" else puts \"Sorry, that's too high. Guess again.\" end end end game = Game.new game.play   In this example, we define a Game class to represent a guessing game. In the initialize method, we use the rand method to generate a random number between 1 and 100, and initialize some game-related variables such as the number of guesses (@guesses) and whether the game is over (@game_over).\nIn the play method, we use a until loop to keep getting guesses from the player until the game is over. In each guess, we call the get_guess method to get a number from the player, and then call the check_guess method to check whether the guess is correct.\nIn the get_guess method, we use the puts method to print a prompt message, and the gets method to get input from the player. In the check_guess method, we first increment the number of guesses, and then check whether the guess is correct. If the guess is correct, we print a congratulatory message and set @game_over to true. Otherwise, we print a message telling the player whether the guess was too high or too low.\nFinally, we create a Game object and call the play method to start the game. Each time the player enters a number, the game tells the player whether the guess was correct or not.\nExample 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person attr_accessor :name, :age, :gender def initialize(name, age, gender) @name = name @age = age @gender = gender end def say_hello puts \"Hi, my name is #{@name}. I'm #{@age}years old and #{@gender}.\" end end # 創建一個人物件 person1 = Person.new(\"David\", 25, \"male\") # 訪問和修改屬性 puts person1.name # David person1.age = 30 puts person1.age # 30 # 呼叫方法 person1.say_hello # Hi, my name is David. I'm 30 years old and male.   這個例子中，我們定義了一個 Person 類別，這個類別具有 name、age 和 gender 三個屬性，以及一個 say_hello 方法。在創建一個人物件時，我們需要提供姓名、年齡和性別等屬性值。我們可以通過使用 attr_accessor 簡化屬性的定義，並使用 initialize 方法來初始化屬性值。在 say_hello 方法中，我們使用實例變數 @name、@age 和 @gender 輸出人物件的屬性值。\n這個例子展示了如何使用 Ruby 物件導向程式設計來建立一個簡單的人物件，並演示了如何訪問和修改物件的屬性，以及如何呼叫物件的方法。\nExample 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Dog def initialize(name, breed) @name = name @breed = breed end def bark puts \"Woof! My name is #{@name}and I'm a #{@breed}.\" end end # 創建一個名為 Spot，品種為柴犬的狗物件 my_dog = Dog.new(\"Spot\", \"Shiba Inu\") # 使用 bark 方法讓狗叫 my_dog.bark   這個程式定義了一個 Dog 類別，該類別有一個 initialize 方法用來初始化名稱和品種的實例變數，以及一個 bark 方法，該方法會讓狗顯示它的名字和品種。程式還創建了一個 my_dog 物件實例，該物件代表一隻名為 “Spot” 的柴犬，然後使用 bark 方法讓狗叫。\nExample 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Car def initialize(make, model, year) @make = make @model = model @year = year @speed = 0 end def speed_up(num) @speed += num puts \"The car is now going #{@speed}mph.\" end def brake(num) @speed -= num puts \"The car is now going #{@speed}mph.\" end def shut_off @speed = 0 puts \"The car is now off.\" end end # 創建一個名為 my_car 的 Car 物件實例 my_car = Car.new(\"Toyota\", \"Camry\", 2015) # 使用 speed_up 方法增加汽車的速度 my_car.speed_up(20) # 再次使用 speed_up 方法增加汽車的速度 my_car.speed_up(30) # 使用 brake 方法減少汽車的速度 my_car.brake(10) # 使用 shut_off 方法關閉汽車 my_car.shut_off   這個程式定義了一個 Car 類別，該類別有一個 initialize 方法用來初始化汽車的屬性（品牌、型號、年份、速度），以及三個方法 speed_up、brake 和 shut_off。這些方法可以讓汽車加速、減速和關閉。程式還創建了一個 my_car 物件實例，該物件代表一輛品牌為 Toyota，型號為 Camry，年份為 2015 的汽車，然後使用 speed_up、brake 和 shut_off 方法操作該汽車的速度和狀態。\nExample 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  class Account attr_reader :balance, :name def initialize(name, balance = 0) @name = name @balance = balance end def deposit(amount) @balance += amount end def withdraw(amount) if amount \u003e @balance puts \"Error: insufficient balance.\" else @balance -= amount end end end class Bank def initialize @accounts = [] end def create_account(name, balance = 0) @accounts \u003c\u003c Account.new(name, balance) end def get_account(name) @accounts.each do |account| if account.name == name return account end end return nil end end my_bank = Bank.new my_bank.create_account(\"Alice\", 1000) my_bank.create_account(\"Bob\", 500) alice_account = my_bank.get_account(\"Alice\") bob_account = my_bank.get_account(\"Bob\") puts alice_account.balance # 輸出 1000 puts bob_account.balance # 輸出 500 alice_account.withdraw(200) puts alice_account.balance # 輸出 800 bob_account.deposit(100) puts bob_account.balance # 輸出 600 alice_account.withdraw(1000) # 輸出 \"Error: insufficient balance.\"   在這個範例中，我們建立了兩個類別（Class），分別是 Account 和 Bank。Account 類別表示一個銀行帳戶物件，它有一個名字（name）和一個餘額（balance）。Bank 類別表示一個銀行系統物件，它可以創建帳戶（create_account）和查詢帳戶（get_account）。\n在 Account 類別中，我們定義了三個方法，分別是 initialize、deposit 和 withdraw。initialize 方法用於初始化一個帳戶，deposit 方法用於存款，withdraw 方法用於取款。在 withdraw 方法中，我們判斷取款金額是否超過帳戶餘額，如果是，就輸出一個錯誤訊息。\n在 Bank 類別中，我們定義了兩個方法，分別是 initialize、create_account 和 get_account。initialize 方法用於初始化一個銀行系統物件，create_account 方法用於創建一個帳戶，get_account 方法用於查詢一個帳戶。\n接著，我們使用 new 方法創建了一個 Bank 物件，並將它儲存在 my_bank 變數中。我們可以使用 my_bank 這個變數，來創建帳戶和查詢帳\n","description":"","tags":null,"title":"Object Oriented Programming","uri":"/posts/oop/"},{"categories":null,"content":"What is “Polymorphism” Polymorphism is a concept in object-oriented programming that refers to the ability of an object to take on many forms or have multiple behaviors. Specifically, it allows different objects to be treated as if they were the same type of object, even if they are different. This means that the same method or operation can be used on different objects, and each object will behave differently based on its own internal implementation.\nPolymorphism is typically achieved through inheritance and method overriding, which allows a subclass to override the implementation of a method inherited from its superclass. This means that different subclasses of the same superclass can have different behaviors for the same method, and can therefore be treated as if they were the same type of object.\nPolymorphism is a key concept in object-oriented programming, as it allows code to be written in a more general and reusable way. By treating objects as if they were the same type of object, code can be written that is more modular, flexible, and easier to maintain, since it can be used with different types of objects without modification.\nExample with Ruby 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Animal def speak puts \"I am an animal\" end end class Dog \u003c Animal def speak puts \"Woof!\" end end class Cat \u003c Animal def speak puts \"Meow!\" end end animals = [Animal.new, Dog.new, Cat.new] animals.each do |animal| animal.speak end # Prints I am an animal # Prints Woof! # Prints Meow!   In this example, we define an Animal class and two subclasses Dog and Cat, both of which override the speak method. We also define an array animals that contains instances of the Animal, Dog, and Cat classes.\nIn the loop, we pass each object in the animals array as an argument to the speak method. Since each object is an instance of a different class, they will exhibit different behaviors. When the Animal object calls the speak method, it will output “I am an animal”; when the Dog object calls the speak method, it will output “Woof!”; when the Cat object calls the speak method, it will output “Meow!”.\nThis example demonstrates how polymorphism can be used to implement different behaviors for different objects. Since the Dog and Cat classes both inherit from the Animal class, they both have a speak method, but the implementation of this method is different. When we call the speak method, Ruby automatically chooses the appropriate method based on the actual type of the object. This is the essence of polymorphism.\nExample with JavaScript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Vehicle { move() { console.log(\"I'm moving\"); } } class Plane extends Vehicle { move() { console.log(\"I'm flying\"); } } class Boat extends Vehicle { move() { console.log(\"I'm on the water\"); } } class Car extends Vehicle {} const vehicle = new Vehicle(); const plane = new Plane(); const boat = new Boat(); const car = new Car(); vehicle.move() // Prints I'm moving plane.move() // Prints I'm flying boat.move() // Prints I'm on the water car.move() // Prints I'm moving   多型是什麼? 多型（polymorphism）是面向物件程式設計（OOP）的一個概念，它允許不同的物件具有相同的介面（方法或屬性），但表現出不同的行為。換句話說，多型是指在不同的情境中，同一個實體（例如一個類別的實例）可以表現出不同的形態和行為。\n多型的實現方式有很多種，其中最常見的是方法重載（method overloading）和方法重寫（method overriding）。方法重載是指在一個類別中定義多個方法，這些方法具有相同的名稱，但是參數類型或數量不同。當調用這些方法時，編譯器會根據實參的類型和數量自動匹配到對應的方法。方法重寫則是指子類重寫父類的方法，在子類中定義一個和父類方法簽名相同的方法，但是實現不同的行為。\n多型是面向物件程式設計的重要特性之一，它可以讓程式更加靈活、可擴展和易維護。通過多型，我們可以編寫通用的程式碼，而不需要針對每個具體的物件編寫不同的程式碼。\n在 Ruby 中，多型通常是通過方法重寫（method overriding）來實現的。上面第一個例子是一個簡單的 Ruby 範例，展示了如何使用多型來實現不同物件的不同行為：\n在這個例子中，我們定義了一個 Animal 類別和兩個子類別 Dog 和 Cat，它們都重寫了 speak 方法。我們還定義了一個陣列 animals，裡面包含了 Animal、Dog 和 Cat 類別的實例。\n在迴圈中，我們將 animals 陣列中的每個物件作為參數傳遞給 speak 方法。由於每個物件都是不同的類別實例，所以它們將表現出不同的行為。當 Animal 物件調用 speak 方法時，它將輸出 “I am an animal”；當 Dog 物件調用 speak 方法時，它將輸出 “Woof!\"；當 Cat 物件調用 speak 方法時，它將輸出 “Meow!\"。\n這個例子展示了如何使用多型來實現不同物件的不同行為。由於 Dog 和 Cat 類別都繼承自 Animal 類別，它們都有一個 speak 方法，但是這個方法的實現是不同的。當我們調用 speak 方法時，Ruby 會根據物件的實際類型自動選擇適當的方法。這就是多型的本質。\n","description":"","tags":null,"title":"Polymorphism","uri":"/posts/polymorphism/"},{"categories":null,"content":"Week 1 and 2 the Golden Square challenges  Learn to test-drive programs with multiple classes. Learn to break programs up into classes. Learn to debug your programs. Learn to build software as a pair. Learn to explain why test-driving, object-oriented design, debugging, and pairing are powerful practices for software engineers.  Goal  I can TDD anything I can program fluently I can debug anything  Week 3 Databases challenges  Design a database schema with at least two tables from a specification, including a one-to-many relationship between two tables, and create the schema in a database using SQL. Use SQL to query a database to read data from one table or resulting of a join, create new records, update and delete. Integrate a relational database to a program by test-driving classes which implement CRUD methods to send SQL queries to a database.  Week 4 Web applications challenges  Explain how HTTP requests and responses work at a high level Write integration tests for a web application Implement web routes using a lightweight web framework Follow a debugging process for a web application Deploy a web application using a light cloud service such as Heroku  ","description":"","tags":null,"title":"Month1 at Makers","uri":"/posts/month1_at_makers/"},{"categories":null,"content":"Week 1 Peer 9.30am we meet with our peer groups. These should run stand-up style to discuss what we did yesterday and intend to do today, as well as a source of connection and support.\nWeek 1 peer group check-in topic Tues\n What do you think a peer group is for? What do you want to use your peer group for?  Wed\n What’s a priority in your life?  Thurs\n What traits in a person do you find challenging? How do you usually handle it?  Fri\n Name a highlight and a challenge that you experienced this week? How did you deal with the challenge?  The Golden Square Challenges (Solo \u0026 Pairs) Phase One: Testing Bites Work through this series of exercises designed to help you learn how to write tests with RSpec.\n Testing Methods With Equality (Exercise One, Exercise Two, Challenge) Testing Classes With Equality (Exercise One, Ecercise Two, Challenge) Testing For Errors (Exercise, Challenge)  Phase Two: Skill Challenges Work through this series of challenges designed to help you learn a strong test-driving, object-oriented design, and debugging practices.\nSome of these challenges include Process Feedback Challenges, in which you record yourself performing the task and share it with your coach for feedback. These are tagged with a 📡.\n Create Your Project Test Drive a Single-Method Program(Exercise, Challenge) Design a Single-Method Program 📡(Design single method recipe template, Exercise One, Exercise Two recipe, Exercise Two, Challenge recipe, Challenge) Intermezzo: Debugging 1(Exercise One, Exercise Two, Challenge) Test Drive a Class(Exercise, Challenge) Design a Class 📡(Design a class recipe template, Exercise recipe, Exercise, Challenge recipe, Challenge) Intermezzo: Debugging 2(Exercise, Challenge)  Notes    Password Checker (Challenge from Testing for errors)    1 2 3 4  it \"should return NoMethod erron when the password is integer\" do password_checker = PasswordChecker.new expect{password_checker.check(123)}.to raise_error(NoMethodError) end   Which can pass the test, but the below is not:\n1 2 3 4 5  it \"should return NoMethod erron when the password is integer\" do password_checker = PasswordChecker.new result = password_checker.check(123) expect{result}.to raise_error(NoMethodError) end   The reason is the result will be assign to “NoMethodError”, so that can not go to the next step. But the first one we catch the error at the mean time.\n  Gratitudes(Challenge from Testing Classes with Equality)    1 2 3 4 5 6  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new gratitude.add(\"sunshine\") result = gratitude.format expect(result).to eq \"Be grateful for: sunshine\" end   Which can pass the test, but the below is not:\n1 2 3 4 5  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new result = gratitude.add(\"sunshine\").format expect(result).to eq \"Be grateful for: sunshine\" end   The reason is because the format method which is defined by ourself, we can not use it in the chain method. If we use the method which ruby defined already, which should be fine. Rewrite like this:\n1 2 3 4 5  it \"should reply grateful for sunshine when the format method is called\" do gratitude = Gratitudes.new result = gratitude.add(\"Sunshine\").push(\"hi\").join(\" \") expect(result).to eq \"Sunshine hi\" end   And it pass the test.\n","description":"","tags":null,"title":"Week1 at Makers","uri":"/posts/week1_at_makers/"},{"categories":null,"content":"Schedule for the first day    Time What     09.45 - 10.45 Welcome to Makers   10.45 - 11.00 BREAK   11.00 - 12.30 Life at Makers by Dana, our Chief Joy Officer   12.30 - 14.00 LUNCH BREAK   14.00 - 15.45 Succeeding at Makers, and beyond…   15.45 - 16.00 BREAK   16.00 - 16.45 Meet the Coaches   16.45 - 17.00 BREAK   17.00 - 17.30 Social time (optional)    Notes (Life at Makers by Dana)  Ask for help, help each other Emotional Intelligence EI EQ Train attention Meditation Mindfulness could be a gym of your brain Neuroplasticity  Notes (Meet the Coaches)   Asking question\n  Putting 100 % in it, but don’t be too stress and worry at should complete it with every details\n  The EQ workshop and meditation really work.\n  Be nice to yourself don’t assume you are the only one have the negative feeling\n  Ask yourself do you know more yesterday, if yes, then you are absolutely on the right process.\n  Do you have fun, enjoy it? Have fun and enjoy it rather then stress.\n  Keep coding, if you feeling don’t want to code anymore, come and talk with the coach.\n  Try it! TDD!\n  It’s tough and uncomfortable, but once you have confident to broke down everything, you can solve the problem.\n  Shared and asked in your cohort channel as possible! How you solve the problem, how you work.Sharing knowledge and you are helping each other.\n  There is lots of skills like problem solving, communication skills matter with career, it’s not only coding\n  Connecting with anyone and help everyone.\n  ","description":"","tags":null,"title":"First day at Makers","uri":"/posts/first_day_at_makers/"},{"categories":null,"content":"Array  Remove Duplicates from Sorted Array  1 2 3 4  def remove_duplicates(nums) nums.uniq! return nums.length end   解法 使用 uniq 篩選出陣列中的不重覆數值並使用!改變原始陣列。 再使用 length 算出陣列長度\nBest Time to Buy and Sell Stock II  1 2 3 4 5 6 7  def max_profit(prices) max_profit = 0 prices.each_cons(2) do |price, next_price| next_price \u003e price \u0026\u0026 max_profit = next_price - price + max_profit end max_profit end   解法\nRotate Array  1 2 3  def rotate(nums, k) nums.rotate!(-k) end   解法 把 nums 使用 rotate 輸轉陣列並使用!改變原始陣列(移動 (-k))\n","description":"","tags":null,"title":"Leetcode","uri":"/posts/leetcode/"},{"categories":null,"content":"RUBY 一、symbols 字串符號 唯一且不會變動的識別名稱 效能比較好，不需要額外的空間來儲存\n字串物件(string)每次都會更新記憶體位置，效能不如symbols但優點是有許多方法可以使用如: reverse, size, downcase\n二、 問號跟驚嘆號\n在 ruby 定義方法時，問號跟驚嘆號也是方法的一部分。\n一般使用問號時，慣例上是表示這個方法會回傳布林值 (true 或 false)\n使用驚嘆號，通常是表示這個方法可能會有「副作用」或「驚喜」，例如陣列有個叫做 uniq 的方法，它可以產生一個元素不重覆的新陣列。\nuniq 方法會回傳一個新的陣列回來，不影響原來的資料\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq p original_list [1, 3, 4, 2, 5, 2, 3] p uniq_list [1, 3, 4, 2, 5]   但如果你是使用有驚嘆號版本的 uniq! 就不同了，原本的陣列也被改變了。\n1 2 3 4 5 6 7  original_list = [1,3,4,2,5,2,3] uniq_list = original_list.uniq! p original_list [1, 3, 4, 2, 5] p uniq_list [1, 3, 4, 2, 5]   三、join、split join 用於將陣列( array )中的元素( element )轉成字串( string )。\nsplit 用於將字串( string )轉成陣列( array )\n四、module 與 modle\n五、namespace\nRails 一、型態 text(文字) 與 string(字串)\ntext 是一種二進位，binary 的格式。可以放的字非常多，可能幾千、幾萬個字，可以使用在如文章內文\nstring 能放的字比較少，使用在文字不會太長的情況，例如文章標題\n二、什麼是 migration\n一種描述資料表該長什麼樣子的描述檔，可以漸進式的去修改你的資料表\n優點: 有紀錄，是一連串的檔案，為資料表的演進過程(欄位變化，新增修改刪除) 可以進行版本控制\n如果要使 migration 具現化，在終端機下指令：\nrails db:migrate 三、CSRF 攻擊\nCSRF (Cross-site request forgery)，跨站請求偽造。目的不一定是要取得使用者帳戶的控制權或個資，但可以用其他使用者的名義執行某些操作。\n這類攻擊的特點是以使用者身份發起\n例如，駭客想刪掉某個 Blog 平台的文章，雖然他沒有這個網站的使用權限，但猜到了後台的路徑: /admin/posts/1便可以使用 delete 方法來刪除。接著把這個連結包裝成中獎資訊，寄送給有權限且剛好處於登入狀態的 X 先生，當 X 先生點下連結，文章就會透過 X 先生的權限來刪除了。\n這個例子中，CSRF 攻擊之所以可以成功，並不是因為駭客獲取 X 先生 的 cookie 資訊，而是偽裝成是 X 先生。\n解決方法:\n 檢查 referer 欄位 (可透過檢查 Header 中的 Referer 欄位是否存在及是否為正常流程網域，藉此確認發送端的前一個頁面是否被偽造或合法使用。) 加入驗證 token (除了驗證 Cookie 的 Token 之外，還需另外在 Request 中放入隱藏的動態 Token 參數。等同於要求每次的 Request 都必須帶上密碼)  四、什麼是 erb 檔 可以在 HTML 裡面寫 ruby 的程式碼。ERb其實可以用來產生任何文字檔格式，例如CSV、XML、JavaScript等等\n五、N+1\nN+1 指的是 SQL 撈資料時，明明可以一次撈完 (例如要三筆資料)，卻使用逐筆撈資料的方式處理 (每次只撈一筆資料) 1次查詢 + N 次的關聯資料查詢就會讓資料庫效能損失\n解決方法: 查詢資料的過程中，使用includes多撈一點資料回來。變成 1 + 1\n六、中控台模式 rails console\nrails c 可在裡面修改資料及查詢資料。 跟 irb 本質上沒有太大差別，中控台模式會把整個 rails 環境，包含相關model 、相關套件整個載下來。\n而 irb 就是一般 ruby 環境\n七、ORM\nObject Relational Mapping\n目的: 簡化資料庫操作語法\n透過物件的方式，去操作資料表，再換句話說， 把物件導向的語法，透過model，轉換成 SQL 查詢語句，對開發人員來說輕鬆很多。撈回來的資料再交給 model 物件化\n例如: Book.all 等同於 select * from books\n SQL 可以被 ORM 取代嗎？\n 當遇到問題時，比如效能，還是需要在 log (紀錄) 裡看 SQL 的語法，看是否寫錯造成翻譯錯誤。 複雜的查詢還是必須使用 SQL 語法   ORM 基本操作 CRUD\nC new 新增一筆資料 create 新增一筆資料，並寫進資料庫 (寫入失敗時默默 rollback) create! 同上，但寫入失敗時會噴錯誤訊息 (可使用 beging rescure 捕捉) R first 找出第一筆資料 last 找出最後一筆資料 find:找出單一筆資料，且只能透過id去搜尋。找不到時 find 會噴錯誤訊息 (例外訊息) find_by 找出單一筆資料，且可以透過自訂條件去搜尋。找不到時 find_by 會回傳的值是nil find_each 資料量大時，預設每次抓 1000 筆 all 找出所有資料 select(’name’) 同上，但只選取 name 欄位 where(name: ‘Happy’) 找出所有 name 欄位是 Ruby 的資料 order(‘id DESC’) 依照 id 大小反向排序 order(id: :desc) 同上 limit(3) 只取出 3 筆資料 count average sum maximum 與 minimum U update update_all increment 欄位的值 + 1 (沒有存檔功能，要記得 save) toggle 把原本的 true / false 值對調 (沒有存檔功能，要記得 save) D delete destroy 刪的過程中，有一連串的 callback destroy_all\nScope\n把商業邏輯寫到 model 裡 取代 controller 一堆 where 是一種類別方法\n八、 MVC\nMVC 架構 Model View Controller\n流程: 一個使用者，透過 route(第一線處理 request 的角色，在 rails 裡非常重要) 導到某一個controller，也許需要調資料(跟model)，也許不用。查完之後(如果需要查詢的話)把資料交還給controller，用 view 去做頁面呈現 (HTML \u0026 CSS)\nModel: 抽象層的概念 model 不是資料表，資料表是 table (實體存在的東西)\nController: 本身是一個 class ， 一個一個的 action 就是方法\nView: 在 controller acton (透過 model 向資料庫) 拿到的 raw data，搭配畫面跟表單，組成一般使用者可以讀的表格、表單\n優點∶ 歸類整齊，易於前後端分工 流程控制: controller 資料邏輯: model 畫面相關: view\n View 技術上來說，其實是會回傳 HTML 內容的方法(method、function)\n 九、資料驗證 前端驗證: 還沒送出去前，在表單用 JavaScript擋下來，缺點驗證是容易被避開 後端驗證: 寫進資料庫之前，如果內容沒填、格式有問題等，把它擋下來。\n在 model 層，比如名字欄位必填，可以使用以下的驗證器\n1  validates :name, presence: true   其他在 rails guide 的 Validation Helpers 還有更多可以使用的驗證\n不寫在 controller 的原因，每一個 controller 要寫去都要做檢查\nmodel 是整包做檢查\n 若同時有不同系統存取資料庫的狀況(比如PHP)，則無法保證資料一定無誤。這時可以在資料庫本體擋掉，比較安全\n  如何繞過驗證 c.save(validate: false)\n 十、 Callback\n資料存檔的流程會經過以下流程: save \u003e valid \u003e before_validation \u003e validate \u003e after_validate \u003e before_save \u003e before_create \u003e create \u003e after_create \u003e after_save \u003e after_commit\nbefore_save 資料寫進跟更新都會執行 before_create 資料被建立的時候才會執行\n十一、 Active Record\n是一種設計模式，本身是一個物件。 每一筆資料包裝成一個物件，並在其增加資料操作邏輯，讓資料的存取更便利\n這個物件，由欄位、基本操作、商業邏輯組成\n我們可以說 MVC 裡的 Model = 依照 Active Record 模式設計的產物\n而 Active Record 是一種 ORM 框架\nActive Record ORM Model Database Table\n十二、二大哲學\n(一) 慣例優於設定 Convention Over Configuration(CoC) 慣例 = 可以少寫不必要的程式碼 學習 Rails ，等於是在學習 Rails 的慣例 例如:\n Model: 大寫、單數 Table: 小寫、複數 每個表格預設會有一個叫做 id 的流水編號欄位 在 migration 裡預設會有個 timestamps，在具現化的時候，會轉換成 created_at updated_at這兩個時間欄位，在資料新增或更新的時候自動寫當下時間 model 跟 table 的對應 pluralize 找出複數名詞的方法 singularize 找出單數名詞的方法 比如  \"person\".pluralize =\u003e \"people\" \"people\".singularize =\u003e \"person\"  若需自定義，在config/initializers/inflections.rb設定\n 檔案跟 model 的對應。類別名稱由兩個以上的單字組成時，Model 名稱應要遵循 Ruby 的命名慣例，採用駝峰式命名，而資料表名稱必須採用底線分隔。 underscore變成蛇式的方法 camlize變成駝峰式 比如  \"HappyHour\".underscore =\u003e \"happy_hour\" \"happy_hour\".camlize =\u003e \"HappyHour\" 外鍵 - 應用資料表的單數形加上 _id 來命名，比如 item_id, order_id。Active Record 會在你建立 Model 之間的關聯時，尋找這種形式的欄位 singularized_table_name_id。  當 model 之間的關連不是用慣例時，必須加上 foreign_key\n比如有一個 store 的 model:\n1  belongs_to :owner #foreign_key: 'owner_id'   foreign_key 是遵循慣例，所以後面可以省略，但如果是接手別人案子或設計，可能原本不是用 ruby 或 rails 寫的，則需寫出 foreign_key 如下\n1  belongs_to :owner foreign_key: 'u_id'    主鍵(流水編號欄位id) - Active Record 預設會使用一個叫做 id 的整數欄位，作為資料表的主鍵。採用 Active Record migration 來建立資料表時，這個欄位會自動產生。\n  參照值\n  user:references 會造出 user_id 這個數字型態欄位 會指向 user 這個 model 的主鍵(流水編號欄位id)\n(二) Don’t repeat yourself\n十三、關聯性\n一對一、一對多、多對多 has_one 不是設定，它是一個類別方法，例子中的 store 是它的參數 執行 has_one 後，會動態做出四個方法，比如\n1 2 3 4 5 6 7  has_one :store #做出以下的方法 #store #store= #build_store(不會直接寫進資料庫) #create_store    1 2 3 4 5  belongs_to :owner #做出以下的方法 #owner #owner=   1 2 3 4 5 6 7  has_many :books #做出以下的方法 #books #books= #build #create   十四、 include、extend、reuqire、load\nrequire,load用於檔案，如.rb等等結尾的檔案。include,load則用於包含一個檔案中的模組 include是引用模組內的方法來擴充實體方法，而extend則是擴充類別方法\n十五、API\n十六、RESTful\n十七、CACHE 暫存\n十八、 Active Job 背景工作\n十九、 前端的 partial 和 helper 差別\n二十、Gemfile 的用意？\n二十一、 namespace\n","description":"","tags":null,"title":"Ruby on Rails 面試題準備","uri":"/posts/interview/"},{"categories":null,"content":"LICEcap可錄製畫面直接存成gif 在專案的使用上非常方便，可以馬上呈現出你製作的功能，讓一起開發的組員一目瞭然。\nMac跟Windows都可以使用 官網下載\nMac使用者記得下載後，到 系統偏好設定 -\u003e 安全性與隱私權 -\u003e 螢幕錄製 裡\n把LICEcap打勾(反灰不能編輯時請按視窗左下角的鎖頭，即可登入權限編輯)\n","description":"","tags":null,"title":"好用工具 LICEcap","uri":"/posts/licecap/"},{"categories":null,"content":"多國語系設置 step. 1 更改預設\nRails 支持多國語系(Internationalization，簡稱I18n)，預設的語系是英文，如要修改，請至config/application.rb\n1 2  config.i18n.available_locales = [:en, :'zh-TW'] #支援語系 config.i18n.default_locale = :'zh-TW' #預設語系   step. 2 新增詞匯檔\n接著，在config/locales新增zh-TW.yml 這個詞匯檔\n1 2  zh-TW:welcome:\"歡迎\"  修改首頁index.html如下\n1  \u003ch1\u003e\u003c%= t('welcome') %\u003e\u003c/h1\u003e   便可以看到首頁的\"welcome\"變成\"歡迎\"\n 檔案副檔名YML是一種YAML Document，格式的縮排必須使用兩個空格\n step. 3 新增Gem\n在Gemfile新增gem \"rails-i18n\" 接著bundle install\nstep. 4 Model字段翻譯\n1 2 3 4 5 6 7 8 9  zh-TW:welcome:\"歡迎\"activerecord:models:feedback:\"回饋\"attributes:feedback:author:\"你的名字\"message:\"訊息\"  就有英文介面及中文介面\nstep. 4 切換多國語系\n 在app/controllers/application_controller.rb新增以下這段  1 2 3 4 5 6 7 8 9 10 11  before_action :set_locale def set_locale if params[:locale] \u0026\u0026 I18n.available_locales.include?( params[:locale].to_sym ) session[:locale] = params[:locale] end I18n.locale = session[:locale] || I18n.default_locale end   接著在app/views/layouts/application.html.erb新增路徑  1 2  \u003c%= link_to \"中文版\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"zh-TW\" %\u003e \u003c%= link_to \"English\", :controller =\u003e controller_name, :action =\u003e action_name, :locale =\u003e \"en\" %\u003e   就可以在頁面看到中文版跟英文版的切換了！\n","description":"","tags":null,"title":"Rails I18n","uri":"/posts/rails_i18n/"},{"categories":null,"content":"用Rails串接第三方支付 MVC\nM = Model 產生訂單的邏輯，比如\n  驗證 validates(使用者名字、金額、訂單編號username 、amount、 order_no)\n  before_create 在本例中是定義build_order_no這個方法\n  enum 在本例中是使用在付款方式的值設定pay_type)\n  V C = Controller 流程控制(產生東西、做什麼事情)\n before_create : 在 rails model 的callback，代表這筆資料被建立的時候我要做什麼事情，呼叫什麼方法。接著可以自己定義方法來使用。 enum : 列舉\n ","description":"","tags":null,"title":"Rails Payment Gateway","uri":"/posts/rails_payment_gateway/"},{"categories":null,"content":"在 rails 上使用 devise 套件 step 1. 在Gemfile加上\ngem 'devise' 或是在該目錄的終端機使用指令% bundle add 'devise'\nstep 2.\n% bundle install step3.\n% rails g devise:install 就會幫我們生成兩個在config下面的檔案\nconfig/initializers/devise.rb config/locales/devise.en.yml 接著在終端機的畫面同時顯示需要完成的指令:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  Some setup you must do manually if you haven't yet: 1. Ensure you have defined default url options in your environments files. Here is an example of default_url_options appropriate for a development environment in config/environments/development.rb: config.action_mailer.default_url_options = { host: 'localhost', port: 3000 } In production, :host should be set to the actual host of your application. 2. Ensure you have defined root_url to *something* in your config/routes.rb. For example: root to: \"home#index\" 3. Ensure you have flash messages in app/views/layouts/application.html.erb. For example: \u003cp class=\"notice\"\u003e\u003c%= notice %\u003e\u003c/p\u003e \u003cp class=\"alert\"\u003e\u003c%= alert %\u003e\u003c/p\u003e 4. You can copy Devise views (for customization) to your app by running: rails g devise:views   一步一步的按照指令完成。\nstep 4.\n% rails g devise User 這個指令會幫我們生成一個migration檔 (db/migrate/20220423155313_devise_create_users.rb) 以及一個新的model檔(app/models/user.rb), 還有在routes.rb新增路徑divise_for :users\nstep 5. 更新資料庫\n% rails db:migrate step 6. 確認路徑\n% rails routes 找出user的路徑\n% rails routes | grep user 可以看到各路徑對照的行為，比如:\n1 2 3  new_user_session (sign_in) destroy_user_session (sign_out) new_user_registration (sign_up)   step 7. sign_up\n在終端機輸入rails s\n開啟http://localhost:3000/users/sign_up 就可以看到註冊頁面了\nstep 8. 清掉cookies\n註冊之後，因為目前的頁面還沒有做sign_out的連結，所以再輸入一次http://localhost:3000/users/sign_up會看到訊息:You are already signed in. 這時候的你，可以打開開發者工具中的Application的Cookies，把該檔案名稱對應的值刪掉，就可以清掉記錄進入到sign_up頁面\nstep 9. Bulma\n參考https://bulma.io/documentation/overview/ 下載Bulma，把樣式表插入app/views/laywout資料夾中的application.html.erb\n1  \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css\"\u003e   接著還要在同個檔案新增meta tag\n1  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e   step 10. 新增navbar 在 app/views 新增shared資料夾，並在裡面新增_navbar.html.erb檔，接著回到laywout的application.html.erb，在body的地方把剛剛的檔案渲染。\n1  \u003c%= render 'shared/navbar' %\u003e   step 11. 編輯navbar\n回到_navbar.html.erb檔，把BULMA的Basic Navbar樣式貼上去，再按照自己的需求編輯:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cnav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\"\u003e \u003cdiv class=\"navbar-brand\"\u003e \u003ca class=\"navbar-item\" href=\"https://bulma.io\"\u003e \u003cimg src=\"https://bulma.io/images/bulma-logo.png\" width=\"112\" height=\"28\"\u003e \u003c/a\u003e \u003ca role=\"button\" class=\"navbar-burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"navbarBasicExample\"\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003cspan aria-hidden=\"true\"\u003e\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e (過長省略，程式碼在: https://bulma.io/documentation/components/navbar/)   step 12. 新增sign_up、sign_out、sign_in連結在_navbar.html.erb檔\n1 2 3 4 5 6 7 8 9  \u003c% if  user_signed_in? %\u003e \u003c%= link_to 'Sign out', destroy_user_session_path, method: :delete, class: \"button is-primary\" %\u003e \u003c% else  %\u003e \u003c%= link_to 'Sign up', new_user_registration_path, class: \"button is-primary\" %\u003e \u003c%= link_to 'Log in', new_user_session_path, class: \"button is-light\" %\u003e \u003c% end %\u003e   step 13. 在首頁印出登入者資料\n1 2 3  \u003c% name  = current_user.present? ? current_user.email : '訪客' %\u003e \u003ch1\u003eWelcome, \u003c%= name %\u003e\u003c/h1\u003e   到這邊為止，就可以看到一個基本的登入頁面了。\n 參考資料:https://youtu.be/jd1gOhpETIA\n ","description":"","tags":null,"title":"Ruby on Rails devise","uri":"/posts/ruby_on_rails_devise/"},{"categories":null,"content":"候選人票選系統純手工打造 ．基本新增修改刪除介紹\n．使用vscode編輯\n．參考資料: 為你自己學Ruby On Rails\n00 開始之前 step 1. 使用指定Rails版本生成專案:\nrails _版本_ new 專案名\n% rails _6.1.5_ new hello_rails step 2. 進到該資料夾 cd hello_rails git版控初始化 git init\nstep 3. 第一次commit git add . git commit -m\"init commit\"\nstep 4. 確定環境正常運作 rails s 進到localhost:3000確認畫面\n01處理Route，新增(建立)路徑 step 1. 找到Route檔 confing -\u003e routes.rb (或是使用ctrl+p搜尋)\nstep 2. 做出候選人相關資源/路徑 在routes.rb檔案裡輸入\n1  resources :candidates   rails routes可查看路徑對照表 可看到做出的八條路徑，對應到七個action\ncandidates#index candidates#create candidates#new candidates#edit candidates#show candidates#update candidates#update candidates#destroy 若只想做出特定路徑，如index跟show，示範如下\n1  resources :candidates, only: [:index, :show]   step 3.新增controllers app -\u003e controllers 按右鍵新增檔案\ncandidates_controller.rb 接著，在檔案裡面輸入\n1 2 3 4 5  class CandidatesController \u003c ApplicationController def index end end   step 4. 新增view app -\u003e views 按右鍵新增資料夾\ncandidates 在candidates裡再新增檔案\nindex.html.erb 輸入\n1  \u003ch1\u003eHi\u003c/h1\u003e   這時，就可以在\nlocalhost:3000/candidates 看到剛剛輸入的Hi了\nstep3-step4手工打造的部分，可使用指令\n% rails g controller candidates 02 新增Model step 1.使用指令新增model\n要先想一下Candidate的Model要有哪些欄位及其對應的資料型態\nModel不等於資料庫/資料表，是一個抽象層的概念\n這個過程如果要純手工，會涉及到需手動建立migration檔來描述這個資料表要長什麼樣子，需要寫一些語法，對現階段的我們來說會有點吃力，建議直接使用指令\n% rails g model Candidate name:string party:string age:integer politics:text votes:integer 如果是文字型態(string)，可省略不寫\n% rails g model Candidate name party age:integer politics:text votes:integer 這個指令會幫你做兩件事\n 建立candidate這個model 會根據你給它的欄位，建位一個migration(主要目的)  慣例:如果model叫Candidate(大寫單數)，資料表migrate中的表格table就會是candidates(小寫複數)\nstep 2.描述檔具現化\n% rails db:migrate 會在 db 這個資料夾建立檔案 檔案名為:\ndevelopment.sqlite3 在rails預設使用的資料庫就是sqlite，它是一種檔案型的資料庫，效能不好，但簡單易用，以練習來說還算堪用，在我們這次開發過程中所有資料都會寫到這裡。\n在config/database.yml裡的adapter可以確認本次專案所使用的資料庫系統\n在不同的環境(開發、測試)，會存放在不同的資料庫\n例如 開發:\ndatabase:db/development.sqlite3 測試:\ndatabase:db/test.sqlite3 03 新增候選人表單 step 1. 確認表單路徑\n在\n% rails routes 找到\ncandidates/new step 2. 寫入連結 回到00章節中 step4 裡在candidates建立的index，在裡面寫入\n1  \u003ca href=\"/candidates/new\"\u003eAdd Candidate \u003c/a\u003e   就可以在\nlocalhost:3000/candidates 頁面看到我們設定的超連結了。但這時點下去這個超連結，應該會出現在錯誤訊息，因為我們還沒有做出相對應的action給它。\nstep 3.定義 new action 回到\ncandidate_controller.rb 定義 new action\n1 2  def new end   step 4. 做出 new 的view\n在views -\u003e candidates 新增檔案\nnew.html.erb 輸入\n1  \u003ch1\u003eAdd Candidate\u003c/h1\u003e   就可以在localhost:1313/candidates/new看到這行新增履歷的文字了\n03-1 手刻建立表單 step 1. 建立 form 表單，使用POST方法\n在 new.html.erb 檔裡寫入\n1 2 3 4  \u003cform action=\"candidates(要去什麼地方)\" method=\"POST(用什麼方式送)\"\u003e \u003cinput type=\"text\" name=\"abc\"\u003e \u003cinput type=\"submit\" value=\"go!\"\u003e \u003c/form\u003e   這邊要稍微記一下(或是可以參考路徑對照表)，在我們從candidates/new這邊，用POST方法往candidates送，那接著就會要找create這個action\ncandidate#create step 2.定義create action 回到\ncandidate_controller.rb 定義 create action\n1 2  def create end   step 3. 認識rails預設的保護機制\n為避免票務或其他相關設計的灌水問題，在使用form表單要往某個地方送的時候，rails會要求要有 authenticiy token。我們可以用以下的 ruby 方法\u003c%= form_authenticity_token %\u003e讓每次載入頁面時，會生出一段authenticity token。按下送出時這段token就會跟著表單一起送到 action。目的是要透過由我們發出去的 authenticity token 來確認用戶是從我們網站進來的，進而達到避免有心人士使用自己寫的程式來不停送出(票數)灌水。\n1  \u003cinput type=\"hidden\" name=\"authenticity_token\" value=\"\u003c%= form_authenticity_token %\u003e\"\u003e   03-2 使用form_for小幫手 在rails裡，有個叫form helper的小幫手，使用它來幫助我們建立表單。就不用像03-1過程這麼繁瑣。\nstep 1. 使用form_for form for 是為了某個model建立表單, 語法如下form_for(model) ，套用在我們這次的實作，因為Candidate是一個class，所以我們在後面加上.new，讓它變成一個model。並把它定義在candidates_controller.rb的new裡。並給它一個實體變數(@)，view才能拿的到。\n(之所以要把model定義在controller裡，是因為在 MVC 結構裡，view 的角色就是單純把東西印出來，不要做產生物件或邏輯運算之類的事，屬於被動角色)\n1 2 3  def new @candidate = Candidate.new end   回到candidates/new，把定義好的實體變數接在form_for裡\n\u003c%= form_for(@candidate) %\u003e form_for 發現後面接的是全新的model的時候，會幫你長出相對應的路徑、方法包含token全部寫完。\nstep 2. 搭配 ruby 的 程式碼區塊(Block) 搭配 ruby的程式碼區塊(Block)do end加上小幫手的.text_field方法來產生欄位，及.label方法來做出標籤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c%= form_for(@candidate) do |form| %\u003e \u003c%= form.label :name %\u003e \u003c%= form.text_field :name %\u003e \u003c%= form.label :party %\u003e \u003c%= form.text_field :party %\u003e \u003c%= form.label :age %\u003e \u003c%= form.text_field :age %\u003e \u003c%= form.label :politics %\u003e \u003c%= form.text_area :politics %\u003e \u003c%= form.submit %\u003e \u003c% end %\u003e   03-3 create action step 1. 得到parameters params 是一個方法會回傳 ActionController::Parameters 物件，在實務上會像一個 hash。所以我們可以透過params來取得parameters。\n在 03-2 把表單建立好，按下送出之後，在 log 中可以發現一包參數(parameters)，裡面包含token、欄位所填的資料 ，我們就可以透過params這個hash，使用candidate這個key來取得相對應的一包hash(value)\n1  params[:candidate]   丟給Candidate.new這個model。接著使用(@)實體變數建立物件，叫這個物件存檔(save)。如果成功，就把頁面導向候選人列表頁。 如果失敗，使用 render 這個方法，借 new 的頁面重新渲染。render :new\n1 2 3 4 5 6 7 8 9  def create @candidate = Candidate.new(params[:candidate]) if @candidate.save redirect_to '/cnadidates' else render :new end end    補充說明 1:hash是什麼? hash是由key、value所組成的資料，設計者只要根據Key值就可以取得相對應的資料。 如何建立hash？ 1.使用hash類別，new一個給他。\nuser = Hash.new\n2.使用大括號 user = { name: ‘Judy’, age:8 }\n  補充說明 2:製造巧合 在 new 及 create 取了一樣的實體變數名字，讓render :new 可以順利在空中抓取資料並透過form_for讓值擺放在相對應的欄位。\n def new @candidate = Candidate.new end def create @candidate = Candidate.new(candidate_params) end step 2. 清洗params 當我們試圖要把整包hash的資料透過 model 寫進資料庫的時候，model會發現這包網路上抓下的東西還沒清洗(過濾檢查)過(使用者可以很輕易的在頁面上編輯加欄位)。預設會擋下來。 使用 require 這個方法，抓取candidate並使用permit只允許部分欄位過來。\n1  params.require(:candidate).permit(:name, :party, :age, :politics)   接著，設定一個變數名稱給它，或是知道我們後面會很常再使用它，可以直接定義方法。再把它放進Candidate.new這個model。\n第一個方式如下:\n1 2 3 4 5 6 7 8 9 10 11  def create clean_params = params.require(:candidate).permit(:name, :party, :age, :politics) @candidate = Candidate.new(clean_params) if @candidate.save redirect_to '/cnadidates' else render :new end end   第二個方式，把它單獨定義一個方法，讓它可以被重複使用，因為不需被外部存取，可以加入 private 註記，變成私有方法。是一個比較好的作法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def create @candidate = Candidate.new(candidate_params) if @candidate.save redirect_to '/candidates' else render :new end end private def candidate_params params.require(:candidate).permit(:name, :party, :age, :politics) end   step 3. 確認存取的資料 在rails console或 rails c輸入\nCandidate.all 就可以印出目前Candidate這個表格裡的所有候選人\nstep 4. 使用者提示 flash flash 是快閃訊息的意思，只要印在畫面一次之後，就會消失。\nflash 本質上就是一個hash。key的慣例上會使用notice，後面再接上要給的訊息。寫的方式如下:\n1  flash[:notice] = \"Candidate created\"   接著，就在要印出這個flash的html頁面寫入\n1  \u003c%= flash[:notice]%\u003e   03-4 加入驗證 在 app -\u003e models 裡的 candidate.rb 檔，根據我們的驗證條件寫入 validates\n1 2 3  calss Candidate \u003c ApplicationRecord validates :name, present:true end   03-5 撈出候選人列表 我們已經順利把候選人寫入資料庫了，現在要把資料撈出來。在candidates_controller.rb這裡透過 Candidate 這個 model 的類別方法 all Candidate.all\n1 2 3  def index @candidates = Candidate.all end   並且在index.html.erb這個檔案裡用table，搭配使用ruby的迴圈each把候選人資料一筆一筆印出來\n03-6 link_to View-helper小幫手link_to\n1  \u003c%= link_to '要秀出來的字樣', '要去的位置'%\u003e   第二種寫法，使用路徑 Prefix 提供的名稱加上 _path\n1  \u003c%= link_to '要秀出來的字樣', new_cnadidate_path %\u003e   第二種寫法的優點  拼錯就會馬上噴錯 之後更改路徑名稱方便  所以盡量以第二種寫法為主。\n03-7 show action step 1. 重覆之前在controller定義action的方式定義show action。注意不要放在private底下。\n1 2  def show end   step 2. 做出view show.html.erb\nstep 3. 透過params拿id欄位回來用\n透過params拿id欄位回來，再透過modle的find_by方法找某候選人的資料\n1  @candidate = Candidate.find_by(id: params[:id])   step 4. 在show.html.erb做列表，把find_by 找到的資料印出來，會根據不同的id而有不同的結果。\nstep 5. 加上 if 判斷 如果候選人有資料，就印出來，反之，印出no record\n1 2 3 4 5 6 7  \u003c% if  @candidate %\u003e #印出資料 \u003c% else %\u003e \u003ch1\u003e No Record Found \u003c/h1\u003e \u003c% end %\u003e    補充說明\n\u003c%= %\u003e 與 \u003c% %\u003e\n兩者的差別在於需不需要於畫面輸出，有加=的會印出來。\n 03-8 沒有通過驗證的錯誤訊息 step 1.透過any?來詢問有沒有任何錯誤訊息\n.errors.any? 這時，對照03-3的save，存檔過程中要是沒有通過驗證，就可以在\n.errors.any? 得到true的結果\n再使用full_messages來得到錯誤訊息\n.errors.full_messages 一樣搭配.each的方法來逐個印出資訊\n1 2 3 4 5 6 7  \u003c% if  candidate.errors.any? %\u003e \u003cul\u003e \u003c% candidate.errors.full_messages.each  do |message| %\u003e \u003cli\u003e\u003c%= message %\u003e\u003c/li\u003e \u003c% end  %\u003e \u003c/ul\u003e    補充說明 可以透過.method的方法來確認有什麼method可以使用\n step2. 修正版面 因為驗證沒有過而render :new 回來後，版面會因為被多了一層div(field_with_errors)包裏而跑掉，我們要怎麼處理呢？\n來到 app -\u003e assets -\u003e stylesheets 資料夾裡按右鍵開一個檔案candidate.scss。這個資料夾裡的所有css檔案可以透過同個資料夾的application.css(打包描述檔)裡的這個描述\n*= require_tree . 打包回來。\n接著，就可以在candidate.scss編輯想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  .field_with_errors{ display: inline-block; input[type=\"text\"]{ border-color: red; border-width: 1px; } label { color: red; } }   04 修改(edit) 一樣使用前面提到的link_to來寫。\nstep 1. 確認路徑\n/candidates/:id/edit step 2. 確認Prefix\nedit_candidate step 3. 在index.html.erb寫入\n1  \u003c%= link_to 'update', edit_candidate_path(candidate.id) %\u003e    補充說明\n若Prefix的欄位是空白的，則對應的是前一個欄位\n 04-1 edit action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def edit @candidate = Candidate.find_by(id: params[:id]) end   step 2. 做出view edit.html.erb\nstep 3. 做一個表單\n(可用new.html.erb的內容來套用)\nstep 4. PATCH / UPDATE 接下來在瀏覽器按下update後，可以在log裡看到form_for幫我們產出的其中一個input，有patch這個方法。\n1  \u003cinput type=\"hidden\" name=\"_method\" value=\"patch\"\u003e   這是因為目前瀏覽器還沒有支援到那麼多的方法(動詞)，所以rails用這個方式\"假裝\"patch(實際上是post)\n由路徑對照表可以看到，如果是用PATCH的方法對/cnadidates/:id這個路徑去送的話，會對應到candidates#update這個方法。\n 補充說明 1.\nrails會根據那個modle是不是全新的來判斷(猜測)form.submit是要使用create還是update\n全新的物件 -\u003e create 從資料庫撈出來的 -\u003e update\n  補充說明 2. (1) 用GET的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#show這個方法 (2) 用PUT的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#update這個方法\n(3) 用DELETE的方法對/cnadidates/:id這個路徑去送的話，會找到candidates#destroy這個方法\n 04-2 update action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3  def update @candidate = Candidate.find_by(id: params[:id]) end   step 2. 類似 create action 的作法，並且失敗的話，借edit的頁面來渲染 1 2 3 4 5 6 7 8 9 10  def update @candidate = Candidate.find_by(id: params[:id]) if @candidate.update(candidate_params) flash[:notice] = \"Candidate updated!\" redirect_to '/cnadidates' else render :edit end end   05 刪除 step 1. 確認路徑\n/candidates/:id step 2. 確認Prefix\ncandidate (沒寫的話的，為同上)\nstep 3. 在index.html.erb寫入\n1  \u003c%= link_to 'delete', candidate_path(candidate.id) %\u003e   step 4. 做出跟update的區別 到目前為止，因為跟update一樣路徑都是在/candidates/:id 所以要在 link_to 裡加幾個參數，讓它不會往show送\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete' %\u003e   在檢視原始碼的時候，就會發現多出data-mathod=\"delete\" 如此，在頁面上按下delete的時候，就會對該路徑使用delete這個動詞，接著往/cnadidates/:id這個路徑去送，會找到candidates#destroy這個方法\n05-1 destroy action step 1. 重覆之前在controller定義action的方式定義edit action。注意不要放在private底下。並且一樣透過params拿id欄位回來，再透過modle的find_by方法找某號候選人的資料\n1 2 3 4 5 6 7  def destroy @candidate = Candidate.find_by(id: params[:id]) @candidate.destroy flash[:notice] = \"Candidate deleted!\" redirect_to '/candidates' end   step 2. 防呆機制 在index.html.erb裡的link_to加上確認data: {confirm:\"\"}\n1  \u003c%= link_to 'delete', candidate_path(candidate.id), method: 'delete', data: { confirm: 'are you sure?' } %\u003e   如此，便可以在刪除資料的時候，跳出確認視窗\n06 錯誤訊息 錯誤訊息的解答通常都在訊息裡\n錯誤訊息:missing a template 代表缺少MVC裡的V(view)，需要在view裡建相對應的 html 給它\n錯誤訊息:Migrations are pending 代表還有一個migrations還沒處理，執行rails db:migrate就可以解決\n錯誤訊息:UnKnown action 代表缺少某個action，需要在 controller 裡定義\n錯誤訊息:Routing Error. No route matches 找不到路徑(有可能是還沒建或是路徑打錯字)\n錯誤訊息:InvalidAuthenticity Token 無有效的驗證\n錯誤訊息:ForbiddenAttributesError 還沒清洗params(還不是白名單)\n rails設計哲學之一就是慣例優於設定\n ","description":"","tags":null,"title":"Ruby on Rails CRUD","uri":"/posts/ruby_on_rails_crud/"},{"categories":null,"content":"環境相關 ruby rvm list 查看電腦裡已經安裝哪些版本的Ruby:\n% rvm list ruby-2.7.2 [ arm64 ] =* ruby-2.7.5 [ arm64 ] =* 符號表示目前正在使用的版本(同時也是目前預設的 Ruby 版本)\nruby -v 查看目前 Ruby 的版本:\n% ruby -v ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [arm64-darwin21] $ rvm use 切換到其他版本的Ruby，例如想要切換到 2.7.2 版本:\n% rvm use 2.7.2 use可省略，例如要切換回2.7.5版本:\n% rvm 2.7.5 --default可設定預設Ruby版本:\n% rvm 2.7.5 --default 這樣之後每次開終端機視窗就會自動切換到 2.7.5 版\nrails gem list 查看電腦裡已經安裝哪些版本的Rails:\n% gem list rails (7.0.2.3, 7.0.2.2, 6.1.5) 或者使用gem list | grep rails\nrails -v 查看目前 Rails 的版本:\n% rails -v Rails 7.0.2.3 gem install rails 安裝最新版本Rails\ngem install rails -v 版本 安裝指定Rails版本:\n% gem install rails -v 6.1.5 rails _版本_ new 專案名使用指定Rails版本生成專案:\n% rails _6.1.5_ new hello_rails ","description":"","tags":null,"title":"Ruby on Rails Environments","uri":"/posts/ruby_on_rails_environments/"},{"categories":null,"content":"JavaScript是一種動態型別的程式語言(Dynamically Typed Language)，使用變量(Variable)及常量(Constant)來儲存數據。變數可以先宣告，再賦值，如:\n1 2  let age age = 20   常數則否，一定要同時進行，如:\n1  const myage = 18   所謂動態型別的程式語言是指，在運行期間才做數據類型檢查的語言。即動態類型語言編緝程式時，永遠不用給任何變量指定數據類型。 該語言會在第一次賦值給變量時，在內部將數據類型記錄下來\n並且充許在運行周期裡，儲存不同類型的數據。 例如:\n1 2  let message = 2; //數值 message = \"Hello World\" //轉換成字串   命名方式  可使用包含字母、數字、$、_ 首字符不能是數字 使用駝峰式命名法(如:myName)  八大資料型別    原始型別(Primitive Type) 物件型別( Object Type)     Boolean Object   Null    Undefined    Number    Bigint    String    Symbol     使用typeof 運算子可以幫助你判斷型別，其中函式（function）和陣列（array）、日期（date）皆為物件(Object)的一種，function 是可呼叫的物件，而 array 是結構較嚴謹的物件。\nFunction 函數  函數是一個行為(action) 一般只執行一個功能 參數可以配默認值參數 = \"默認值\" 可以返回或不返回值，返回值時需使用return  Async Await promise的出現，目標是為了解決callback hell的現象，而Async Await則是為了讓非同步執行變得更簡潔，更直觀\ncallback -\u003e promise -\u003e Async Await\n特點:\n 更貼近同步執行程式碼 概念是由promise基礎上演變 Async Await會返回promise object Await關鍵字只能在Async function裡使用，必須尾隨promise object 使用try catch語句捕捉Async Await出現的錯誤  ","description":"","tags":null,"title":"Beginner JavaScript Notes","uri":"/posts/java_script_notes/"},{"categories":null,"content":"陣列的 map、filter 跟 reduce 三個常用的方法介紹 在介紹這三個方法之前，先帶大家了解何謂\"callback function\"。\n引用 MDN 的說明如下:\n 回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。它會在外部函式內調用，以完成某些事情。\n 簡單來說，就是一個程式執行完再去執行另一個程式，並且是在指定時機才觸發的。\n接著我們來看這三個方法在 W3Schools 中的說明\n map() Creates a new array with the result of calling a function for each array element\n  語法let new_array = arr.map(function callback( currentValue[, index[, array]]) {// return element for new_array}[, thisArg])\n  filter() Creates a new array with every element in an array that pass a test\n  語法var newArray = arr.filter(function callback(element[, index[, array]])[, thisArg])\n  reduce() Reduce the values of an array to a single value (going left-to-right)\n  語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n 根據語法我們可以發現這三個方法都是 callback function。\n翻成中文的意思大概如下:\nmap() 方法會建立一個新陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。\nfilter() 方法會建立一個每一個元素經過指定運算判斷後回傳為真的新陣列。\nreduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。\nreduce 方法跟 map、filter 的差別是它會 return 一個值，而不是一個新陣列，這會連帶使 reduce 的語法結構跟邏輯與其他方法不太相同。\n看起來有點複雜，其實就是使用 callback 函式處理陣列中的每個元素，可傳入以下四個參數，我們再對照語法來看一次:\n 語法arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue)\n  accumulator：累加器;經由個別 currentValue 加總的累計值 currentValue：Array 正在處理的元素 currentIndex(選擇性)：正在處理的元素索引 array(選擇性)：原始陣列  initialValue(選擇性)：初始值(預設值)，放在 function 的最後方，於第一次呼叫 callback 時要傳入的累加器初始值。若沒有提供初始值，則原陣列的第一個元素將會被當作初始的累加器。\n","description":"","tags":null,"title":"filter, map and reduce in JS","uri":"/posts/java_script_method/"}]
